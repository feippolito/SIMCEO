
\section{Introduction}
\label{sec:introduction}

This documents describes SIMCEO, an interface between CEO and Simulink.
SIMCEO allows to seamlessly integrates CEO functionalities into a Simulink model.
A Simulink library, \emph{CEO}, provides a set of blocks that are used to instantiate CEO objects.
The blocks either send data to the CEO objects updating the state of these objects, or query data from the CEO objects.
The data received from the CEO objects is then forwarded to the other blocks of the Simulink model. 

\section{Installation}
\label{sec:installation}

This section describes the installation of the SIMCEO client i.e. the Matlab and Simulink part of SIMCEO.

To install SIMCEO on your computer, creates a directory \texttt{SIMCEO}, downloads the archive \texttt{simceo.zip} and extracts it in the \texttt{SIMCEO} directory.

In addition to Matlab and Simulink, the client relies of aws cli, ZeroMQ and UBJSON.

\subsection{AWS command line interface}
\label{sec:aws-cli}

The AWS command line interface (\texttt{aws cli}) allows to launch/terminate and to start/stop the AWS instances where the SIMCEO server resides.
To install it, follows the instructions at \\ \url{http://docs.aws.amazon.com/cli/latest/userguide/installing.html} \\
Once installed, open a terminal and at the shell prompt enter: \\\texttt{>> aws configure --profile gmto.control}\\ and answers the questions using the \texttt{gmto.control.credentials} file provided separately.

At Matlab prompt enter: \texttt{>> system('aws --version')}.
If Matlab cannot find \texttt{aws}, replace \texttt{aws} in \texttt{etc/simceo.json} by the full path to \texttt{aws}.

\subsection{Matlab--ZMQ}
\label{sec:zeromq}

Matlab--ZMQ\footnote{\url{https://github.com/fagg/matlab-zmq}} is a Matlab wrapper for ZeroMQ.
ZeroMQ \footnote{\url{http://zeromq.org/}} is the messaging library used for the communications between SIMCEO client and server.
Both Matlab--ZMQ and ZeroMQ are shipped pre--compiled with SIMCEO. 
You need however to add, to the Matlab search path, the path to ZeroMQ.
To do so, move Matlab current folder to SIMCEO folder and at the Matlab prompt enter:
\\\texttt{>> addpath([pwd,'/matlab-zmq/your-os/lib/'])}\\\texttt{>> savepath}\\
where \texttt{your-os} is either \texttt{unix}, \texttt{mac} \texttt{windows7} or \texttt{windows10}.

\subsection{UBJSON}
\label{sec:ubjson}

Universal Binary JSON (UBJSON\footnote{\url{http://ubjson.org/}}) is the message format used to exchange data between SIMCEO client and server.
The Matlab UBJSON encoder and decoder is JSONLAB.
SIMCEO comes with its own version of JSONLAB that fixes a few bugs.
To add JSONLAB to the Matlab search path, move Matlab current folder to SIMCEO folder and at the Matlab prompt enter:
\\\texttt{>> addpath([pwd,'/jsonlab/'])}\\\texttt{>> savepath}\\

\section{Implementation}
\label{sec:implementation}

The interface between CEO and Simulink has two components a Matlab package \emph{ceo} on the user computer, the client, and a python module \emph{simulink} on a CEO AWS instance, the server.
A flowchart of SIMCEO is shown in Fig.~\ref{simceo-flowchart}.
The Matlab package is written with custom blocks using a \emph{Level--2 Matlab S--function}.
A \emph{Level--2 Matlab S--function} consists in a collection of functions that are called by the Simulink engine when a model is running.
Inside the \emph{Level--2 Matlab S--function}, the functions \emph{Start}, \emph{Terminate} and \emph{Outputs} are used to exchange information with CEO.
The Matlab class \emph{broker}  is responsible for starting the CEO server in the AWS cloud and for managing the communication with the server.

The requests from the client are managed by the \emph{broker} class of the \emph{simulink} python module on the server.
The \emph{simulink} module is providing three python classes to deal with Simulink requests: \emph{SGMT}, \emph{SAtmosphere} and \emph{SOpticalPath}.

The communication between the client and the server uses the Request/Reply messaging pattern of ZeroMQ.
The messages exchanged between the client and the server are formatted according to the UBJSON format.

\begin{figure}
  \label{simceo-flowchart}
  \centering
  \input{simceo.flowchart.tex}    
  \caption{SIMCEO flowchart.}
\end{figure}

\section{The simulink python module}
\label{sec:simul-pyth-module}

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{simulink.png}
  \caption{The classes in the simulink python module and their relations with the CEO classes.}
\end{figure}

The python interface consists in the module \emph{simulink}:
<<simceo.py>>=
import sys
import threading
import time
import zmq
import ubjson
import ceo
import numpy as np
from collections import OrderedDict
import os
import shelve
import traceback

SIMCEOPATH = os.path.abspath(os.path.dirname(__file__))
currentTime = 0.0;

class testComm:
    def __init__(self):
        pass
    def hello(self,N=1):
        data = np.ones(N)
        return dict(data=data.tolist())

class Timer(object):
    def __init__(self, name=None):
        self.name = name

    def __enter__(self):
        self.tstart = time.time()

    def __exit__(self, type, value, traceback):
        if self.name:
            print '[%s]' % self.name,
        print 'Elapsed time: %s' % (time.time() - self.tstart)

<<CalibrationMatrix>>

<<S-function>>

<<SGMT>>
<<SAtmosphere>>
<<SOpticalPath>>

<<broker>>

if __name__ == "__main__":

    agent = broker()
    agent.start()
 
@

\subsection{The broker class}
\label{sec:broker-class}

% There are two broker classes, one written with python and acting as the CEO server, and the other is the Simulink client written with Matlab.

% \subsubsection{CEO server}
% \label{sec:ceo-server}

The broker class receives requests from the Simulink S--functions, processes the requests and sends a replies to the Simulink client.
%The broker class is the CEO server.
%It replies to requests received from the Simulink S--functions.
%It relies on ZeroMQ to send and receive messages to and from a Simulink model.
It inherits from the \emph{threading.Thread} class.
<<broker>>=
class broker(threading.Thread):

    def __init__(self):

        threading.Thread.__init__(self)
        
        self.context = zmq.Context()
        self.socket = self.context.socket(zmq.REP)
        self.address = "tcp://*:3650"
        self.socket.bind(self.address)
        
        self.ops = []
        self.n_op = 0
        self.satm = SAtmosphere(self.ops)
        self.sgmt = SGMT(self.ops, self.satm)

    def __del__(self):

        self.release()

    def release(self):

        self.socket.close()
        self.context.term()

    <<broker get item>>

    <<broker run>>
@ 
The \emph{run} method 
<<broker run>>=
def run(self):
    
    while True:

        <<broker run details>>
@ 
waits for a request from a Simulink S--function:
<<broker run details>>=
msg = self.socket.recv()
#jmsg = ubjson.loadb(msg)
try:
    jmsg = ubjson.loadb(msg)
except Exception as E:
    #print "Error raised by ubjson.loadb by that does not stop us!"
    print msg
    raise
@
The message received from the S--function contains
\begin{itemize}
\item a class identifier, \emph{class\_id}: \textbf{GMT} for \emph{SGMT}, \textbf{ATM} for \emph{SAtmosphere} or \textbf{OP} for \emph{SOpticalPath},
\item a method identifier, \emph{method\_id}: \textbf{Start}, \textbf{Terminate}, \textbf{Update} or \textbf{Outputs},
\item a dictionnary of the arguments to the method,  \emph{args}.
\end{itemize}
The class method is invoked with:
<<broker run details>>=
global currentTime
currentTime = float( jmsg["currentTime"][0][0] )
class_id  = jmsg["class_id"]
method_id = jmsg["method_id"]
#print "@ %.3fs: %s->%s"%(currentTime,jmsg["tag"],method_id)
#tid = ceo.StopWatch()
try:
    #tid.tic()
    args_out = getattr( self[class_id], method_id )( **jmsg["args"] )
    #tid.toc()
    #print "%s->%s: %.2f"%(class_id,method_id,tid.elapsedTime) 
except Exception as E:
    print "@(broker)> The server has failed!"
    print jmsg
    traceback.print_exc()
    print "@(broker)> Recovering gracefully..."
    class_id = ""
    args_out = "The server has failed!"
@ 
The dictionary--like call is implemented with 
<<broker get item>>=
def __getitem__(self,key):
    if key=="GMT":
        return self.sgmt
    elif key=="ATM":
        return self.satm
    elif key[:2]=="OP":
        if key[2:]:
            op_idx = int(key[2:]) - self.n_op + len(self.ops)
            return self.ops[op_idx]
        else:
            self.ops.append( SOpticalPath( len(self.ops) ,
                                           self.sgmt.gmt ,
                                           self.satm ) )            
            self.n_op = len(self.ops)
            return self.ops[-1]
    elif key=='testComm':
        return testComm()
    else:
        raise KeyError("Available keys are: GMT, ATM or OP")
@ 
Each optical paths that is defined in the Simulink model is affected an unique ID tag made of the string \textbf{OP} followed by the index of the object in the optical path list \emph{ops}.
If the ID tag of the optical path is just \textbf{OP}, a new \emph{SOpticalPath} object is instanciated and appended to the list of optical path.

When the \emph{Terminate} method of an \emph{SOpticalPath} object is called, the object is removed from the optical path list \emph{ops}. 
<<broker run details>>=
if class_id[:2]=="OP" and method_id=="Terminate":
    self.ops.pop(0)
@
The value return by the method of the invoked object is sent back to the S--function:
<<broker run details>>=
self.socket.send(ubjson.dumpb(args_out,no_float32=True))
@

\subsection{The S classes}
\label{sec:s-classes}

The S classes, \emph{SGMT}, \emph{SAtmosphere} and \emph{SOpticalPath}, are providing the interface with CEO classes. 
They mirror the \emph{Level--2 Matlab S--functions} by implementing the same method \emph{Start}, \emph{InitializeConditions}, \emph{Terminate}, \emph{Update} and \emph{Outputs}.
Each method is triggered by the corresponding function in the Matlab S--function with the exception of the \emph{Update} method that is triggered by the \emph{Outputs} function of the S--function.

An abstract class, \emph{Sfunction}, implements the four S--function method:
<<S-function>>=
from abc import ABCMeta, abstractmethod

class Sfunction:
    __metaclass__ = ABCMeta
    @abstractmethod
    def Start(self):
        pass
    @abstractmethod
    def Terminate(self):
        pass
    @abstractmethod
    def Update(self):
        pass
    @abstractmethod
    def Outputs(self):
        pass
    @abstractmethod
    def InitializeConditions(self):
        pass
@ 

\subsubsection{The SGMT class}
\label{sec:sgmt-class}

The \emph{SGMT} class is the interface class between a CEO \emph{GMT\_MX} object and a \emph{GMT Mirror}  Simulink block.
<<SGMT>>=
class SGMT(Sfunction):

    def __init__(self, ops, satm):
        self.gmt  = ceo.GMT_MX()

    def Terminate(self, args=None):
        self.gmt = ceo.GMT_MX()
        return "GMT deleted!"
@

\paragraph{Start}

The message that triggers the call to the \emph{Start} method is
<<SGMT Start message>>=     
{
"class_id": "GMT",
"method_id": "Start",
"args": 
  {
    "mirror": "M1"|"M2",
    "mirror_args": 
      {
        "mirror_modes": u"bending modes"|u"zernike",
        "N_MODE": 162,
	"radial_order": ...
      }
  }
}
@
<<SGMT>>=
    def Start(self,mirror=None,mirror_args=None):
        self.gmt[mirror] = getattr(ceo,"GMT_"+mirror)( **mirror_args )
        return "GMT"
@

\paragraph{Update}

The message that triggers the call to the \emph{Update} method is
<<SOpticalPath Update message>>=     
{
"class_id": "GMT",
"method_id": "Update",
"args": 
  {
    "mirror": "M1"|"M2",
    "inputs_args":
      {
        "TxyzRxyz": null,
        "mode_coefs": null
      }
  }
}
@
<<SGMT>>=
    def Update(self, mirror=None, inputs_args=None):
        for key in inputs_args:
            data = np.array( inputs_args[key], order='C', dtype=np.float64 )
            data = np.transpose( np.reshape( data , (-1,7) ) )
            if key=="TxyzRxyz":
                self.gmt[mirror].motion_CS.origin[:]       = data[:,:3]
                self.gmt[mirror].motion_CS.euler_angles[:] = data[:,3:]
                self.gmt[mirror].motion_CS.update()
            elif key=="mode_coefs":
                self.gmt[mirror].modes.a = np.copy( data, order='C')
                self.gmt[mirror].modes.update()
@
\paragraph{InitializeConditions}

<<SGMT>>=
    def InitializeConditions(self, args=None):
        pass
@
\paragraph{Outputs}

<<SGMT>>=
    def Outputs(self, args=None):
        pass
@ 

\subsubsection{The SAtmosphere class}
\label{sec:satmosphere-class}

The \emph{SAtmosphere} class is the interface class between a CEO \emph{GmtAtmosphere} object and a \emph{Atmosphere} Simulink block.
<<SAtmosphere>>=
class SAtmosphere(Sfunction):

    def __init__(self, ops):
        self.ops = ops
        self.atm = None
        self.samplingTime = None

    def Start(self,samplingTime=1.0, **kwargs):
        self.atm = ceo.JGmtAtmosphere( **kwargs )
        self.samplingTime = samplingTime
        return "ATM"

    def Terminate(self, args=None):
        self.atm = None
        return "Atmosphere deleted!"

    def InitializeConditions(self, args=None):
        pass

    def Outputs(self, args=None):
        pass

    def Update(self, args=None):
        pass
@ 

\subsubsection{The SOpticalPath class}
\label{sec:sopticalpath-class}

The \emph{SOpticalClass} gathers a source object \emph{src}, the GMT model object 
\emph{gmt}, an atmosphere object \emph{atm}, a sensor object \emph{sensor} and a calibration source \emph{calib\_src}.
<<SOpticalPath>>=
class SOpticalPath(Sfunction):

    def __init__(self, idx, gmt, satm):
        self.idx = idx
        self.gmt = gmt
        self.satm = satm
	self.sensor = None
        self.D = {}
@
\paragraph{Start}

The message that triggers the call to the \emph{Start} method is
<<SOpticalPath Start message>>=     
{
"class_id": "OP",
"method_id": "Start",
"args": 
  {
    "source_args": { ... } ,
    "sensor_class": null|"Imaging"|"ShackHartmann",
    "sensor_args": null|{ ... },
    "calibration_source": null|{ ... },...
    "miscellaneous_args": null|{...}
  }
}
@ 
<<SOpticalPath>>=
    def Start(self,source_args=None, sensor_class=None, sensor_args=None, 
              calibration_source_args=None, miscellaneous_args=None):
        self.propagateThroughAtm = miscellaneous_args['propagate_through_atmosphere']
        self.src = ceo.Source( **source_args )
        if sensor_class is not None:

            self.sensor = getattr(ceo,sensor_class)( **sensor_args )
            if calibration_source_args is None:
                self.calib_src = self.src
            else:
                self.calib_src = ceo.Source( **calibration_source_args )
	
            self.sampleTime     = miscellaneous_args['sampleTime']
            self.exposure_time  = int(np.round(miscellaneous_args['exposure_time']/self.sampleTime))
            if self.exposure_time<=0:
                self.exposure_time = 1
            self.exposure_start = int(np.round(miscellaneous_args['exposure_start']/self.sampleTime))

	    self.src.reset()
	    self.gmt.reset()
            self.gmt.propagate(self.src)
	    self.sensor.calibrate(self.calib_src,miscellaneous_args['intensity_threshold'])
            if isinstance(self.sensor,(ceo.ShackHartmann,ceo.GeometricShackHartmann,ceo.GMTLIB.TT7)):
                print "# of valid slopes: %d"%self.sensor.n_valid_slopes
                self.slopes = np.zeros( shape=(self.sensor.n_valid_slopes,1) )

            self.comm_matrix = {}

        return "OP"+str(self.idx)
@
\paragraph{Terminate}

The message that triggers the call to the \emph{Terminate} method is
<<SOpticalPath Terminate message>>=     
{
"class_id": "OP",
"method_id": "Terminate",
"args": 
  {
    "args": null
  }
}
@ 
<<SOpticalPath>>=
    def Terminate(self, args=None):
        return "OpticalPath deleted!"
@
\paragraph{Update}

The message that triggers the call to the \emph{Update} method is
<<SOpticalPath Update message>>=     
{
"class_id": "OP",
"method_id": "Update",
"args": 
  {
    "inputs": null
  }
}
@ 
<<SOpticalPath>>=
    def Update(self, inputs=None):
        self.src.reset()
        self.gmt.propagate(self.src)
        if self.propagateThroughAtm:
            #sys.stdout.write("\r@(SAtmosphere)> Simulation time: %.3gs"%self.stime)
            #sys.stdout.flush()
            #tid = ceo.StopWatch()
            delta = self.src.rays.L/(self.src.rays.N_L-1)
            nPx   = self.src.rays.N_L
            #tid.tic()
            self.satm.atm.ray_tracing(self.src,delta,nPx,delta,nPx,currentTime)
            #tid.ping()
        if self.sensor is not None and (currentTime/self.sampleTime)>self.exposure_start:
            self.sensor.propagate(self.src)
@ 

\paragraph{Outputs}

The message that triggers the call to the \emph{Outputs} method is
<<SOpticalPath Outputs message>>=     
{
"class_id": "OP",
"method_id": "Outputs",
"args": 
  {
      "outputs": ["wfe_rms"|"segment_wfe_rms"|"piston"|"segment_piston"|"ee80"]
  }
}
@ 
<<SOpticalPath>>=
    def Outputs(self, outputs=None):
        next_exposure_start = int(np.round(currentTime/self.sampleTime))
        exposure_end        = self.exposure_time + self.exposure_start
        if self.sensor is not None and next_exposure_start==exposure_end:
            self.sensor.process()
            if isinstance(self.sensor,(ceo.ShackHartmann,ceo.GeometricShackHartmann,ceo.GMTLIB.TT7)):
                self.slopes = self.sensor.valid_slopes.host(
                    shape=(self.sensor.n_valid_slopes,1) )

        doutputs = OrderedDict()
        for element in outputs:
            doutputs[element] = self[element]

        if self.sensor is not None and next_exposure_start==exposure_end:
            self.sensor.reset()
            #self.sensor.readOut(self.exposureTime,0)
            self.exposure_start = next_exposure_start

        return doutputs
@ 
and the dictionnary implementation is
<<SOpticalPath>>=
    def __getitem__(self,key):
        if key=="wfe_rms":
            return self.src.wavefront.rms(units_exponent=-6).tolist()
        elif key=="segment_wfe_rms":
            return self.src.phaseRms(where="segments",units_exponent=-6).tolist()
        elif key=="piston":
            return self.src.piston(where="pupil",units_exponent=-6).tolist()
        elif key=="segment_piston":
            return self.src.piston(where="segments",units_exponent=-6).tolist()
        elif key=="tiptilt":
            return self.src.wavefront.gradientAverage(1,self.src.rays.L).host(units='arcsec').tolist()
        elif key=="segment_tiptilt":
            return self.gmt.segmentsWavefrontGradient(self.src).host(units='arcsec').tolist()
        elif key=="ee80":
            return self.sensor.ee80().tolist()
        else:
            c = np.dot(self.comm_matrix[key], self.slopes ).reshape(1,-1)
            return c.tolist()
@
\paragraph{InitializeConditions}

The message that triggers a call to the \emph{InitializeConditions} method is
<<SOpticalPath InitializeConditions message>>=     
{
"class_id": "OP",
"method_id": "InitializeConditions",
"args": 
  {
      "calibrations":
      {
          "M2_TT":
          {
            "mirror": "M2",
            "mode": "segment tip-tilt",
            "stroke": 1e-6
          }
          "M12_Rxyz": [
          {
            "mirror": "M1",
            "mode": "Rxyz",
            "stroke": 1e-6
          },
          {
            "mirror": "M2",
            "mode": "Rxyz",
            "stroke": 1e-6
          }]
      }
      "calibration_file": null,
      "SVD_truncation": 0
  }
}
@
<<SOpticalPath>>=
    def InitializeConditions(self, calibrations = None, 
                                   calibration_file = None,
                                   SVD_truncation = 0):
        print "@(SOpticalPath:InitializeConditions)>"
        if calibrations is not None:
            #import scipy.io.matlab as matlab
            k = 0
            if not isinstance(SVD_truncation,list):
                SVD_truncation = [SVD_truncation]
            if calibration_file is not None:
                filepath = os.path.join(SIMCEOPATH,"calibration_dbs",calibration_file)
                db = shelve.open(filepath)
                if os.path.isfile(filepath+".dir"):
                    print " . Loading command matrix from existing database %s!"%calibration_file
                    for key in db:
                        C = db[key]
                        C.nThreshold = SVD_truncation[k]
                        k+=1
                        self.comm_matrix[key] = C.M
                        db[key] = C
                    db.close()
                    self.gmt.reset()
                    self.src.reset()
                    self.sensor.reset()
                    self.gmt.propagate(self.src)
                    self.sensor.propagate(self.src)
                    self.sensor.process()
                    return
            with Timer():
                for key in calibrations: # Through calibrations
                    calibs = calibrations[key]
                    if not isinstance(calibs,list):
                        calibs = [calibs]
                    D = []
                    for c in calibs: # Through calib
                        self.gmt.reset()
                        self.src.reset()
                        self.sensor.reset()
                        D.append( self.gmt.calibrate(self.sensor,self.src,**c) )
                    self.gmt.reset()
                    self.src.reset()
                    self.sensor.reset()
                    self.gmt.propagate(self.src)
                    self.sensor.propagate(self.src)
                    self.sensor.process()

                    Dc = np.concatenate( D, axis=1 )
                    C = CalibrationMatrix(Dc, SVD_truncation[k])
                    k+=1
                    #matlab.savemat('poke_matrix.mat',{'D':Dc})
                    self.comm_matrix[key] = C.M

                    if calibration_file is not None:
                        print " . Saving command matrix to database %s!"%calibration_file
                        db[str(key)] = C

            if calibration_file is not None:
                db.close()
@ 

\subsection{The CalibrationMatrix class}
\label{sec:calibr-class}

The \emph{CalibrationMatrix} class is a container for several matrices:
\begin{itemize}
\item the poke matrix $D$,
\item the eigen modes $U,V$ and eigen values $S$ of the singular value decomposition of $D=USV^T$
\item the truncated inverse $M$ of $D$, $M=V\Lambda U^T$ where
  \begin{eqnarray}
    \label{eq:2}
      \Lambda_i &=& 1/S_i,\quad \forall i<n \nonumber\\
      \Lambda_i &=& 0,\quad \forall i\geq n \nonumber    
  \end{eqnarray}
\end{itemize}

<<CalibrationMatrix>>=
class CalibrationMatrix(object):

    def __init__(self, D, n):
        print "@(CalibrationMatrix)> Computing the SVD and the pseudo-inverse..."
        self.D = D
        self._n = n
        with Timer():
            self.U,self.s,self.V = np.linalg.svd(D,full_matrices=False)
            self.V = self.V.T
            iS = 1./self.s
            if self._n>0:
                iS[-self._n:] = 0
            self.M = np.dot(self.V,np.dot(np.diag(iS),self.U.T))
            
    @property
    def nThreshold(self):
        "# of discarded eigen values"
        return self._n
    @nThreshold.setter
    def nThreshold(self, value):
        print "@(CalibrationMatrix)> Updating the pseudo-inverse..."
        self._n = value
        iS = 1./self.s
        if self._n>0:
            iS[-self._n:] = 0
        self.M = np.dot(self.V,np.dot(np.diag(iS),self.U.T))
@
\subsection{The Sensor abstract class}
\label{sec:sens-abstr-class}

<<Sensor abstract class>>=
class Sensor:
    __metaclass__ = ABCMeta
    @abstractmethod
    def calibrate(self):
        pass
    @abstractmethod
    def reset(self):
        pass
    @abstractmethod
    def analyze(self):
        pass
    @abstractmethod
    def propagate(self):
        pass
    @abstractmethod
    def process(self):
        pass
@ 

\section{The ceo Matlab package}
\label{sec:ceo-matlab-package}

\begin{figure}
  \centering
  \input{simceo.matlab.tex}
  \caption{SIMCEO Matlab client flowchart.}
  \label{fig:1}
\end{figure}
\subsection{The broker class}
\label{sec:matlab-broker-class}


<<broker.m>>=
classdef (Sealed=true) broker < handle
    % broker An interface to a CEO server
    %  The broker class launches an AWS instance and sets up the connection
    %  to the CEO server
    
    properties
        awspath % full path to the AWS CLI
        instance_id % The AWS instance ID number
        public_ip % The AWS instance public IP
        zmqReset % ZMQ connection reset flag
	elapsedTime
    end
    
    properties (Access=private)
        etc
        instance_end_state
        ctx
        socket
    end
    
    methods

        <<broker client>>

        <<release ressources>>

        <<launch AWS AMI>>

        <<start AWS instance>>

        <<terminate AWS instance>>
    end
    
    methods(Static)

        <<instanciation and retrieval>>

        <<request and reply>>

        <<reset ZMQ socket>>

        <<time spent>>
        
    end

end
@ %def awspath instance_id public_ip zmqReset 
The Matlab broker class starts an AWS machine and sets--up ZeroMQ context and socket.
<<broker client>>=
function self = broker(varargin)

    self.ctx    = zmq.core.ctx_new();
    self.socket = zmq.core.socket(self.ctx, 'ZMQ_REQ');
    self.zmqReset = true;
    
    self.elapsedTime = 0;

    currentpath = mfilename('fullpath');
    k = strfind(currentpath,filesep);
    self.etc = fullfile(currentpath(1:k(end)),'..','etc');
    cfg = loadjson(fullfile(self.etc,'simceo.json'));
    self.awspath         = cfg.awsclipath;
    self.instance_id     = cfg.aws_instance_id;
    <<broker client: AWS instance launch>>
end
@
If no instance ID is given, a new machine is launched based on a given AWS AMI.
<<broker client: AWS instance launch>>=
if isempty(self.instance_id)
    run_instance(self)
    self.instance_end_state = 'terminate';
else
    start_instance(self)
    self.instance_end_state = 'stop';
end
@
\subsubsection{run\_instance}
\label{sec:run_instance}

If no instance ID is set in the \texttt{simceo.json} configuration file, a new instance is created from the AMI whose ID is given in \texttt{etc/ec2runinst.json} file. 
<<launch AWS AMI>>=
function run_instance(self)
    <<launching an instance>>
    <<waiting for the running state>>
    <<waiting for initialization>>
    <<branding instance>>
    <<setting up cloudwatch>>
    <<getting the public IP>>    
end
@ 
The sequence of operations is:
\begin{enumerate}
\item launching the instance,
<<launching an instance>>=
cmd = sprintf(['%s ec2 run-instances --profile gmto.control ',...
               '--cli-input-json file://%s'],...
              self.awspath, fullfile(self.etc,'ec2runinst.json'));
[status,instance_json] = system(cmd);
if status~=0
    error('Launching AWS AMI failed:\n%s',instance_json)
end
instance = loadjson(instance_json);
self.instance_id = instance.Instances{1}(1).InstanceId;
@ 
\item waiting for the confirmation that the instance is running (See page \pageref{itm:instanceRunning}),
\item waiting for the confirmation that the instance has finished to initialize,
<<waiting for initialization>>=
fprintf('>>>> WAITING FOR AWS INSTANCE %s TO INITIALIZE ... \n',self.instance_id)
fprintf('(This usually takes a few minutes!)\n')
tic
cmd = sprintf(['%s ec2 wait instance-status-ok --instance-ids %s ',...
               '--profile gmto.control'],...
              self.awspath,self.instance_id);
[status,~] = system(cmd);
toc
if status~=0
    error('Starting AWS machine %s failed!',self.instance_id')
end
@ 
\item setting up the instance name
<<branding instance>>=
[~,username] = system('whoami');
[~,hostname] = system('hostname');
cmd = sprintf('%s ec2 create-tags --resources %s --tags Key=Name,Value=%s',...
              self.awspath,self.instance_id,...
              ['SIMCEO(',strtrim(username),...
               '@',strtrim(hostname),')']);
system(cmd);
@ 
\item setting up an alarm that terminates an instance idle for man than 4hours,
<<setting up cloudwatch>>=
cmd = sprintf(['%s cloudwatch put-metric-alarm ',...
               '--profile gmto.control ',...
               '--dimensions Name=InstanceId,Value=%s ',...
               '--cli-input-json file://%s'],...
              self.awspath,...
              self.instance_id,...
              fullfile(self.etc,'cloudwatch.json'));
[status,~] = system(cmd);
if status~=0
    error('Setting alarm for AWS machine %s failed!',self.instance_id')
end
@ 
\item getting the public IP of the instance (See page \pageref{itm:publicIP}).
\end{enumerate}
@
\subsubsection{terminate\_instance}
\label{sec:terminate_instance}

<<terminate AWS instance>>=
function terminate_instance(self)
    if strcmp(self.instance_end_state,'terminate')
        fprintf('@(broker)> Terminating instance %s!\n',self.instance_id)
        [status,~] = system(sprintf(['%s ec2 %s-instances',...
                            ' --instance-ids %s --profile gmto.control'],...
                                    self.awspath, self.instance_end_state,...
				    self.instance_id));
        if status~=0
            error('Terminating AWS instance %s failed!',self.instance_id')
        end
    end
end
@
\subsubsection{start\_instance}
\label{sec:start_instance}

If an instance ID has been set in the \texttt{simceo.json} configuration file, this instance is started.
<<start AWS instance>>=
function start_instance(self)
    <<starting an instance>>
    <<waiting for the running state>>
    <<getting the public IP>>
end
@
The sequence of operations is:
\begin{enumerate}
\item starting the instance:
<<starting an instance>>=
cmd = sprintf(['%s ec2 start-instances --instance-ids %s',...
               ' --profile gmto.control'],...
              self.awspath,self.instance_id);
fprintf('%s\n',cmd)
fprintf('@(broker)> Starting AWS machine %s...\n',self.instance_id)
[status,cmdout] = system(cmd);
if status~=0
    error('Starting AWS machine %s failed:\n%s',self.instance_id,cmdout)
end
@ 
\item waiting for the confirmation that the instance is running\label{itm:instanceRunning}
<<waiting for the running state>>=
fprintf('>>>> WAITING FOR AWS INSTANCE %s TO START ... \n',self.instance_id)
tic
[status,~] = system(sprintf(['%s ec2 wait instance-running --instance-ids %s',...
                    ' --profile gmto.control'],...
                            self.awspath,self.instance_id));
toc
if status~=0
    error('Starting AWS machine %s failed!',self.instance_id')
end
@ 
\item getting the public IP of the instance\label{itm:publicIP}.
<<getting the public IP>>=
cmd = sprintf(['%s ec2 describe-instances --instance-ids %s',...
               ' --output text',...  
               ' --query Reservations[*].Instances[*].PublicIpAddress',...
               ' --profile gmto.control'],...
              self.awspath,self.instance_id);
[status,public_ip_] = system(cmd);
if status~=0
    error('Getting AWS machine public IP failed!')
end
self.public_ip = strtrim(public_ip_);
fprintf('\n ==>> machine is up and running @%s\n',self.public_ip)
@
\end{enumerate}
@
Once the instance is running, ZeroMQ connects the client to the server port of ZeroMQ on the AWS instance:
<<broker client: setup ZMQ connection>>=
self.socket = zmq.core.socket(self.ctx, 'ZMQ_REQ');
status = zmq.core.setsockopt(self.socket,'ZMQ_RCVTIMEO',60e3);
if status<0
    error('broker:zmqRcvTimeOut','Setting ZMQ_RCVTIMEO failed!')
end
status = zmq.core.setsockopt(self.socket,'ZMQ_SNDTIMEO',60e3);
if status<0
    error('broker:zmqSndTimeOut','Setting ZMQ_SNDTIMEO failed!')
end
address     = sprintf('tcp://%s:3650',self.public_ip);
zmq.core.connect(self.socket, address);
fprintf('@(broker)> %s connected at %s\n',class(self),address)
@
The allocated ZeroMQ ressources are released with:
<<release ressources>>=
function delete(self)
    fprintf('@(broker)> Deleting %s\n',class(self))
    terminate_instance(self)    
    zmq.core.close(self.socket);
    zmq.core.ctx_shutdown(self.ctx);
    zmq.core.ctx_term(self.ctx);
end
@
Two static methods are defined.
\emph{getBroker} instanciates and retrieves the broker object.
There can be only one broker object per Matlab session.
<<instanciation and retrieval>>=
function self = getBroker(varargin)
% getBroker Get a pointer to the broker object
%
% agent = ceo.broker.getBroker() % Launch an AWS instance and returns
% a pointer to the broker object
% agent = ceo.broker.getBroker('awspath','path_to_aws_cli') % Launch
% an AWS instance using the given AWS CLI path and returns a pointer to
% the broker object
% agent =
% ceo.broker.getBroker('instance_id','the_id_of_AWS_instance_to_start') 
% Launch the AWS instance 'instance_id' and returns a pointer to the broker object
    
    persistent this
    if isempty(this)
        fprintf('~~~~~~~~~~~~~~~~~~~')
        fprintf('\n SIMCEO CLIENT!\n')
        fprintf('~~~~~~~~~~~~~~~~~~~\n')
        this = ceo.broker(varargin{:});
    end
    self = this;
end
@
\emph{sendrecv} sends a request to the server and returns the server reply:
<<request and reply>>= 
function jmsg = sendrecv(send_msg)
    tid = tic;
    self = ceo.broker.getBroker();
    jsend_msg = saveubjson('',send_msg);
    zmq.core.send( self.socket, uint8(jsend_msg) );
    rcev_msg = -1;
    count = 0;
    while all(rcev_msg<0) && (count<15)
        rcev_msg = zmq.core.recv( self.socket , 2^24);
        if count>0
            fprintf('@(broker)> sendrecv: Server busy (call #%d)!\n',15-count)
        end
        count = count + 1;
    end
    if count==15
        set_param(gcs,'SimulationCommand','stop')
    end
    jmsg = loadubjson(char(rcev_msg),'SimplifyCell',1);
    if ~isstruct(jmsg) && strcmp(char(jmsg),'The server has failed!')
        disp('Server issue!')
        set_param(gcs,'SimulationCommand','stop')
    end    
    self.elapsedTime = self.elapsedTime + toc(tid);
end
@ 
\emph{resetZMQ} resets the ZeroMQ socket
<<reset ZMQ socket>>=
function resetZMQ()
    self = ceo.broker.getBroker();
    if self.zmqReset
        [~,aws_instance_state] = system(...
            sprintf(['%s ec2 describe-instances --instance-ids %s',...
                     ' --output text',...
                     ' --query Reservations[*].Instances[*].State.Name ',...
                     '--profile gmto.control'],...
            self.awspath, self.instance_id));
        if any(strcmp(strtrim(aws_instance_state),{'shutting-down','terminated'}))
            run_instance(self)
        end
        zmq.core.close(self.socket);
        <<broker client: setup ZMQ connection>>
    end
    self.zmqReset = false;
end
function setZmqResetFlag(val)
    self = ceo.broker.getBroker();
    self.zmqReset = val;
end
@ 
Time spent communicating:
<<time spent>>=
function timeSpent()
    self = ceo.broker.getBroker();
    fprintf('@(broker)> Time spent communicating with the server: %.3fs\n',...
    			self.elapsedTime)
    self.elapsedTime = 0;
end
@ 

\subsection{The dealer class}
\label{sec:the-dealer-class}

The \emph{dealer} class contains the messages that are sent by the different functions of the S--function.
Each CEO block instantiates a \emph{dealer} class and tailors the messages in the initialization of the block mask.
It also holds the number of inputs and outputs of the block as well as the dimensions of the inputs and outputs.  
<<dealer.m>>=
classdef dealer < handle

    properties
        n_in
        dims_in
        n_out
        dims_out
        start
        update
        outputs
        terminate
        init
        sampleTime
        tag
    end

    properties (Dependent)
        currentTime
        class_id
    end

    properties (Access=private)
        p_currentTime
        p_class_id		
        tid
    end

    methods
        
        <<dealer public methods>>
            
    end
    
    methods (Access=private)
        
        <<dealer private methods>>

    end
 end
@ %def n_in dims_in n_out dims_out start update outputs terminate init
There are five messages that corresponds to 4 four S--function routines:
<<dealer public methods>>=
function self = dealer(class_id,tag)

    self.p_class_id = class_id;
    self.tag = strrep(tag,char(10),' ');
    proto_msg = struct('currentTime',[],...
                       'class_id',self.p_class_id,...
                       'method_id','',...
                       'tag',self.tag,...
                       'args',struct('args',[])); 
    % Start
    self.start     = proto_msg;
    self.start.method_id = 'Start';
    % InitializeConditions
    self.init      = proto_msg;
    self.init .method_id = 'InitializeConditions'; 
    % Outputs
    self.update    = proto_msg;
    self.update.method_id  = 'Update';
    self.outputs   = proto_msg;
    self.outputs.method_id = 'Outputs';
    % Terminate
    self.terminate = proto_msg;
    self.terminate.method_id = 'Terminate';
end
@ 
Both, the \emph{currentTime} and the \emph{class\_id} properties trigger an update of all the messages:         
<<dealer public methods>>=
function val = get.class_id(self)
    val = self.p_class_id;
end
function set.class_id(self,val)
    self.p_class_id = val;
    self.start.class_id     = val;
    self.init.class_id      = val;
    self.update.class_id    = val;
    self.outputs.class_id   = val;
    self.terminate.class_id = val;
end
function val = get.currentTime(self)
    val = self.p_currentTime;
end
function set.currentTime(self,val)
    self.p_currentTime = val;
    self.start.currentTime     = val;
    self.init.currentTime      = val;
    self.update.currentTime    = val;
    self.outputs.currentTime   = val;
    self.terminate.currentTime = val;
end

@
\subsubsection{Public methods}
\label{sec:public-methods}

The properties of the blocks inputs and outputs are set with:
<<dealer public methods>>=        
function IO_setup(self,block)
    block.NumInputPorts  = self.n_in;
    for k_in=1:self.n_in
        block.InputPort(k_in).Dimensions  = self.dims_in{k_in};
        block.InputPort(k_in).DatatypeID  = 0;  % double
        block.InputPort(k_in).Complexity  = 'Real';
        block.InputPort(k_in).DirectFeedthrough = true;
    end
    block.NumOutputPorts = self.n_out;
    for k_out=1:self.n_out
        block.OutputPort(k_out).Dimensions   = self.dims_out{k_out};
        block.OutputPort(k_out).DatatypeID   = 0; % double
        block.OutputPort(k_out).Complexity   = 'Real';
        block.OutputPort(k_out).SamplingMode = 'sample';
    end
    block.SampleTimes = self.sampleTime;
end
@ 
The names of the output ports are set with:
<<dealer public methods>>=
function output_names(self,port_handle)
    for k_out=1:self.n_out
        set(port_handle.Outport(k_out), ...
	    'SignalNameFromLabel', self.outputs.args.outputs{k_out})
    end
end
@
The \emph{deal} method sends the message to the CEO server, waits for the server replies and process the reply.
<<dealer public methods>>=        
function deal(self,block,tag)
    self.currentTime = block.currentTime;
    switch tag
      case 'start'
        deal_start(self);
      case 'init'
        deal_init(self);
      case 'IO'
        deal_inputs(self, block);
        deal_outputs(self, block);
      case 'terminate'
        deal_terminate(self);
      otherwise
        fprintf(['@(dealer)> deal: Unknown tag;',...
                 ' valid tags are: start, init, IO and terminate!'])
    end
end
@
The messages are concatenated into a single json file with:
<<dealer public methods>>=
function dump(self)
    s = struct('start',     self.start,...
               'init',      self.init,...
               'update',    self.update,...
               'outputs',   self.outputs,...
               'terminate', self.terminate);
    delete([gcs,'#*.json'])
    savejson('',s,strrep(strrep(strrep([gcb,'.json'],'/','#'),' ','_'),char(10),'_'));
end
@ 
\subsubsection{Private methods}
\label{sec:private-methods}

<<dealer private methods>>=        
function deal_start(self)
    ceo.broker.resetZMQ()
    jmsg = ceo.broker.sendrecv(self.start);
    self.class_id = char(jmsg);
    fprintf('@(%s)> Object created!\n',self.tag)
    self.tid = tic;
end

function deal_init(self)
    ceo.broker.sendrecv(self.init);
    fprintf('@(%s)> Object calibrated!\n',self.tag)
    self.tid = tic;
end

function deal_terminate(self)
    toc(self.tid)
    jmsg = ceo.broker.sendrecv(self.terminate);
    dump(self)
    fprintf('@(%s)> %s\n',self.tag,jmsg)
    ceo.broker.setZmqResetFlag(true)
    ceo.broker.timeSpent()
end
@ 
\emph{deal\_inputs} reads the block inputs and affects the input data to the corresponding field in the update message:
<<dealer private methods>>=                
        function deal_inputs(self, block)
            if self.n_in>0
                fields = fieldnames(self.update.args.inputs_args);
                for k_in=1:self.n_in
                    self.update.args.inputs_args.(fields{k_in}) = ...
                                          reshape(block.InputPort(k_in).Data,1,[]);
                end
            end
            ceo.broker.sendrecv(self.update);
        end
@ 
\emph{deal\_outputs} affects the inputs from the CEO server to the corresponding data field of the block outputs:
<<dealer private methods>>=                
        function deal_outputs(self, block)
            if self.n_out>0
                outputs_msg = ceo.broker.sendrecv(self.outputs);
                try
                    fields = fieldnames(outputs_msg);
                catch ME
                    disp('ERROR in output_msg:')
                    outputs_msg
                    rethrow(ME)
                end
                for k_out=1:self.n_out
                    data = outputs_msg.(fields{k_out});
                    if isempty(data)
                        data = NaN(size(block.OutputPort(k_out).Data));
                    end
                    if iscell(data)
                        data = cellfun(@(x) double(x), data{1});
                    else
                        data = double(data);
                    end
                    block.OutputPort(k_out).Data = data;
                end
            end
        end
@ 

\subsection{The SCEO S--function}
\label{sec:sceo-s-function}

<<SCEO.m>>=
function SCEO(block)

setup(block);

<<SCEO setup>>

<<SCEO Start>>

<<SCEO Outputs>>

<<SCEO Terminate>>
@
\subsubsection{setup}
\label{sec:setup}

<<SCEO setup>>=
function setup(block)

msg_box   = get(gcbh,'UserData');
fprintf('__ %s: SETUP __\n',msg_box.tag)
% Register number of ports
%block.NumInputPorts  = 0;

% Setup port properties to be inherited or dynamic
%block.SetPreCompInpPortInfoToDynamic;
%block.SetPreCompOutPortInfoToDynamic;

IO_setup(msg_box, block)

% Register sample times
%  [0 offset]            : Continuous sample time
%  [positive_num offset] : Discrete sample time
%
%  [-1, 0]               : Inherited sample time
%  [-2, 0]               : Variable sample time
%block.SampleTimes = [1 0];

% Specify the block simStateCompliance. The allowed values are:
%    'UnknownSimState', < The default setting; warn and assume DefaultSimState
%    'DefaultSimState', < Same sim state as a built-in block
%    'HasNoSimState',   < No sim state
%    'CustomSimState',  < Has GetSimState and SetSimState methods
%    'DisallowSimState' < Error out when saving or restoring the model sim state
block.SimStateCompliance = 'DefaultSimState';

%% -----------------------------------------------------------------
%% The MATLAB S-function uses an internal registry for all
%% block methods. You should register all relevant methods
%% (optional and required) as illustrated below. You may choose
%% any suitable name for the methods and implement these methods
%% as local functions within the same file. See comments
%% provided for each function for more information.
%% -----------------------------------------------------------------

block.RegBlockMethod('Start', @Start);
block.RegBlockMethod('Outputs', @Outputs);     % Required
block.RegBlockMethod('Update', @Update);
block.RegBlockMethod('Terminate', @Terminate); % 
block.RegBlockMethod('PostPropagationSetup', @PostPropagationSetup);
block.RegBlockMethod('InitializeConditions', @InitializeConditions);
%end setup

function PostPropagationSetup(block)
msg_box   = get(gcbh,'UserData');
fprintf('__ %s: PostPropagationSetup __\n',msg_box.tag)
output_names(msg_box,get(gcbh, 'PortHandles'))

function InitializeConditions(block)
msg_box   = get(gcbh,'UserData');
fprintf('__ %s: InitializeConditions __\n',msg_box.tag)
deal(msg_box,block,'init')
@
\subsubsection{Start}
\label{sec:start}

<<SCEO Start>>=
function Start(block)

msg_box   = get(gcbh,'UserData');
fprintf('__ %s: START  __\n',msg_box.tag)
deal(msg_box,block,'start')
%set(gcbh,'UserData',msg_box)
%end Start
@
\subsubsection{Outputs}
\label{sec:outputs}
 
<<SCEO Outputs>>=
function Outputs(block)

msg_box   = get(gcbh,'UserData');
%fprintf('__ %s: OUTPUTS __\n',msg_box.class_id)

deal(msg_box,block,'IO')

%end Outputs
@
\subsubsection{Terminate}
\label{sec:terminate}

<<SCEO Terminate>>=
function Update(block)

%end Update

function Terminate(block)

msg_box = get(gcbh,'UserData');
deal(msg_box,block,'terminate')
%set(gcbh,'UserData',[])
%end Terminate
@ 

\subsection{The block masks}
\label{sec:block-masks}

\subsubsection{Optical Path}
\label{sec:optical-path}

<<OpticalPath.md>>=
# Optical Path

## Guide Star Tab

#### Zenith angle

The guide star zenith angle, in arcsecond, given with respect to 
the telescope optical axis.

#### Azimuth angle

The guide star azimuth angle in degree.

#### Photometry

The guide star photometry to choose from.
This will set the wavelength, the spectral bandwidth and the magnitude zero
point.

The table below gives the values of those:

                             V       R       I       J       H       K       Ks 
--------------             -------- ------- ------- ------- ------- ------- -------
$\lambda$[$\mu$m]            0.550   0.640   0.790   1.215   1.654   2.179   2.157 
$\Delta\lambda$[$\mu$m]      0.090   0.150   0.150   0.260   0.290   0.410   0.320
Zero point[m$^{-2}.s^{-1}$]  8.97E9  10.87E9 7.34E9  5.16E9  2.99E9  1.90E9 1.49E9
--------------             -------- ------- ------- ------- ------- ------- -------- 

#### Magnitude

The guide star magnitude used to derive the number of photon taking
into account the guide star photometry.

#### \# of rays per lenslet

The \# of rays per lenslet corresponds to the number of rays used
for ray tracing through the telescope.
It has different meanings depending on the value of Sensor (See below).

### Sensor

The type of sensor:

* `None`: No sensor is used; 
the \# of rays per lenslet corresponds to the number of rays
across the telescope diameter, 
* `Imaging`: The sensor creates an image at the focal plane of the telescope; 
the \# of rays per lenslet corresponds to the number of rays
across the diameter of the imaging lens, 
* `ShackHartmann`: A shack-Hartmann model where the wavefront of the guide star is 
propagated from the telescope exit pupil to the focal plane of the lenslet array
using Fourier optics propagation; 
the \# of rays per lenslet corresponds to the number of rays across one lenslet,
* `GeometricShackHartmann`: A shack-Hartmann model where the centroids are derived 
from the finite difference of the wavefront averaged on the lenslets; 
the \# of rays per lenslet corresponds to the number of rays across one lenslet.
* `TT7`:  A shack-Hartmann model where the centroids are derived 
from the finite difference of the wavefront averaged on each segment of the GMT;
the \# of rays per lenslet corresponds to the number of rays across the telescope diameter.

#### Source FWHM

The full width at half maximum of the source intensity profile assuming a Gaussian intensity distribution.
The FWHM is given in units of pixel before binning.

#### Propagate through the atmosphere

If checked, the guide star is propagated through the atmosphere using the model defined in the atmosphere block.

#### Sample Time

The sampling time of the block outputs that also corresponds to the exposure time of the detector of the wavefront sensor.

## Sensor Tab

#### \# of lenslet

The linear size of the lenslet array.

#### lenslet size

The physical length of one lenslet project on M1 in meter.

#### camera resolution

The detector resolution of the optical sensor in pixel.

#### Intensity threshold

The threshold on the lenslet integrated flux. Any lenslet, whose fraction of integrated intensity with respect to a fully illuminated lenslet is less than the threshold, is discarded.

#### Pixel scale

The angular size of a pixel of the detector in arcsec.
It is given by 
$(\lambda/d)(b/a)$
where both $a$ and $b$
are integers

#### Field-of-view

The field-of-view of the wavefront sensor in arcsec.

## Outputs Tab

### Star

Each output is derived on the telescope full pupil and/or on each segment.

#### Wavefront error rms

The RMS of the guide star wavefront in micron.

#### Piston

The piston component of the guide star wavefront in micron.

#### Tip-tilt

The tip-tilt component of the guide star wavefront in arcsec.
 
### Sensor

#### EE80

The 80% encircled energy diameter in pixel. 

#### Commands: Load calibration from file

The name of the file where the calibration matrices are saved to.
If the file already exists on the CEO server, the calibration matrices are loaded from this file.

#### Commands: Calibration inputs

A ShackHartmann or GeometricShackHartmann sensor can return an estimate of
the mirror commands based on its measuremnts.
The mirror commands are given by the matrix multiplication of
the inverse of the poke matrix and the sensor measurements.
To generate the poke matrix, CEO needs to know which modes to calibrate
from which mirror (`M1` or `M2`) and what stroke to apply to these modes.

The available mirror modes are: 

* `segment tip-tilt`: to calibrate the tip (Rx) and tilt (Ry) of each segment,
* `Txyz`: to calibrate the translation of each segment along its x, y and z axis,
* `Rxyz`: to calibrate the rotation of each segment along its x, y and z axis,
* `zernike`: to calibrate the Zernike modes of each segment,
* `bending modes`: to calibrate the bending modes of M1.

For example:

* to calibrate M2 segment tip--tilt, the calibration inputs argument is 
```matlab
struct('M2_TT',struct('mirror','M2','mode','segment tip-tilt','stroke',1e-6)) 
```
where `M2_TT` is the name of the output port consisting of the 14 tip and tilts,

* to calibrate all M1 modes and to concatenate all the modes into a single calibration matrix, the calibration inputs argument is 
```matlab
struct('M1_RTBM',[struct('mirror','M1','mode','Rxyz','stroke',1e-6),...
	              struct('mirror','M1','mode','Txyz','stroke',1e-6),...
                  struct('mirror','M1','mode','bending modes','stroke',1e-6)])
```

#### Commands: Command vector length

The length of the different command vector defined with calibration inputs.
For the examples in Calibration inputs, the length of the command vector are 14 for M2_TT and 20+20+7*n_mode for M1_RTBM.
Modes Rz and Tz for segment #1 of M1 are un-observable by the WFS.
Only mode Rz for segment #1 of M2 is un-observable by the WFS.

For M2_TT, the output vector has the following structure: $[R_{xy}^1,R_{xy}^2,R_{xy}^3,R_{xy}^4,R_{xy}^5,R_{xy}^6,R_{xy}^7]$.
For M1_RTBM, the output vector is: $[R_{xyz},T_{xyz},BM]$ with $(R_{xyz} \equiv X,T_{xyz} \equiv X,BM \equiv X)$ and $X=[X^1,X^2,X^3,X^4,X^5,X^6,X^7]$.

#### Commands: SVD truncation

The number of eigen values, from the singular value decomposition of the calibration matrix, that are discarded.
If the calibration is loaded from a previously saved file, the threshold is re-applied and the pseudo-inverse is re-computed.

@ 
\subsubsection{GMT Mirror}
\label{sec:gmt-mirror}

<<GMTMirror.md>>=
# GMT Mirror

#### Mirror

Either the primary M1 or the secondary M2 mirror.

### Mirror commands

The mirrors accept two types of intputs:

#### Txyz and Rxyz rigid body

A $7\times6$ matrix concatenating row wise the vectors `[Tx,Ty,Tz,Rx,Ry,Rz]` of segments 1 to 7.

#### Mirror mode coefficients

The coefficients of the segments modal basis that is used to shape the segments.
It is a $7\times$`n_mode` matrix of either bending mode for M1 or Zernike coefficients for M2.
@ 
\section{The CEO server}
\label{sec:ceo-server-1}

The CEO daemon is start at boot time with the \emph{CEO.sh} shell script.
It must be placed in the \texttt{/etc/init.d} directory.
<<CEO.sh>>=
#!/bin/bash -e

DAEMON="/usr/bin/env LD_LIBRARY_PATH=/usr/local/cuda/lib64 PYTHONPATH=/home/ubuntu/CEO/python /home/ubuntu/anaconda/bin/python /home/ubuntu/Dropbox/SIMCEO/simceo.py"
daemon_OPT=""  
DAEMONUSER="root" 
daemon_NAME="ceo_server" 
PIDFILE=/var/run/$daemon_NAME.pid

PATH="/sbin:/bin:/usr/sbin:/usr/bin" #Ne pas toucher

#test -x $DAEMON || exit 0

. /lib/lsb/init-functions

d_start () {
        log_daemon_msg "Starting system $daemon_NAME Daemon"
        start-stop-daemon --background --name $daemon_NAME --start --quiet --make-pidfile --pidfile "$PIDFILE" --chuid $DAEMONUSER --exec $DAEMON -- $daemon_OPT
        log_end_msg $?
}

d_stop () {
        log_daemon_msg "Stopping system $daemon_NAME Daemon"
        start-stop-daemon --name $daemon_NAME --stop --retry 5 --quiet --pidfile "$PIDFILE" --name $daemon_NAME
        log_end_msg $?
}

case "$1" in

        start|stop)
                d_${1}
                ;;

        restart|reload|force-reload)
                        d_stop
                        d_start
                ;;

        force-stop)
               d_stop
                killall -q $daemon_NAME || true
                sleep 2
                killall -q -9 $daemon_NAME || true
                ;;

        status)
                status_of_proc "$daemon_NAME" "$DAEMON" "system-wide $daemon_NAME" && exit 0 || exit $?
                ;;
        *)
                echo "Usage: /etc/init.d/$daemon_NAME {start|stop|force-stop|restart|reload|force-reload|status}"
                exit 1
                ;;
esac
exit 0
@ 

\section{Index} 
\nowebindex
\section{List of code chunks}
\nowebchunks
