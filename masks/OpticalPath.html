<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #e9967a; } /* Char */
code > span.st { color: #e9967a; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #e9967a; } /* SpecialChar */
code > span.vs { color: #e9967a; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<h1 id="optical-path">Optical Path</h1>
<h2 id="guide-star-tab">Guide Star Tab</h2>
<h4 id="zenith-angle">Zenith angle</h4>
<p>The guide star zenith angle, in arcsecond, given with respect to the telescope optical axis.</p>
<h4 id="azimuth-angle">Azimuth angle</h4>
<p>The guide star azimuth angle in degree.</p>
<h4 id="photometry">Photometry</h4>
<p>The guide star photometry to choose from. This will set the wavelength, the spectral bandwidth and the magnitude zero point.</p>
<p>The table below gives the values of those:</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="center">V</th>
<th align="center">R</th>
<th align="center">I</th>
<th align="center">J</th>
<th align="center">H</th>
<th align="center">K</th>
<th align="center">Ks</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline"><em>λ</em></span>[<span class="math inline"><em>μ</em></span>m]</td>
<td align="center">0.550</td>
<td align="center">0.640</td>
<td align="center">0.790</td>
<td align="center">1.215</td>
<td align="center">1.654</td>
<td align="center">2.179</td>
<td align="center">2.157</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline"><em>Δ</em><em>λ</em></span>[<span class="math inline"><em>μ</em></span>m]</td>
<td align="center">0.090</td>
<td align="center">0.150</td>
<td align="center">0.150</td>
<td align="center">0.260</td>
<td align="center">0.290</td>
<td align="center">0.410</td>
<td align="center">0.320</td>
</tr>
<tr class="odd">
<td align="left">Zero point[m<span class="math inline"><em></em><sup>−2</sup>.<em>s</em><sup>−1</sup></span>]</td>
<td align="center">8.97E9</td>
<td align="center">10.87E9</td>
<td align="center">7.34E9</td>
<td align="center">5.16E9</td>
<td align="center">2.99E9</td>
<td align="center">1.90E9</td>
<td align="center">1.49E9</td>
</tr>
</tbody>
</table>
<h4 id="magnitude">Magnitude</h4>
<p>The guide star magnitude used to derive the number of photon taking into account the guide star photometry.</p>
<h4 id="of-rays-per-lenslet"># of rays per lenslet</h4>
<p>The # of rays per lenslet corresponds to the number of rays used for ray tracing through the telescope. It has different meanings depending on the value of Sensor (See below).</p>
<h3 id="sensor">Sensor</h3>
<p>The type of sensor:</p>
<ul>
<li><code>None</code>: No sensor is used; the # of rays per lenslet corresponds to the number of rays across the telescope diameter,</li>
<li><code>Imaging</code>: The sensor creates an image at the focal plane of the telescope; the # of rays per lenslet corresponds to the number of rays across the diameter of the imaging lens,</li>
<li><code>ShackHartmann</code>: A shack-Hartmann model where the wavefront of the guide star is propagated from the telescope exit pupil to the focal plane of the lenslet array using Fourier optics propagation; the # of rays per lenslet corresponds to the number of rays across one lenslet,</li>
<li><code>GeometricShackHartmann</code>: A shack-Hartmann model where the centroids are derived from the finite difference of the wavefront averaged on the lenslets; the # of rays per lenslet corresponds to the number of rays across one lenslet.</li>
<li><code>TT7</code>: A shack-Hartmann model where the centroids are derived from the finite difference of the wavefront averaged on each segment of the GMT; the # of rays per lenslet corresponds to the number of rays across the telescope diameter.</li>
</ul>
<h4 id="source-fwhm">Source FWHM</h4>
<p>The full width at half maximum of the source intensity profile assuming a Gaussian intensity distribution. The FWHM is given in units of pixel before binning.</p>
<h4 id="propagate-through-the-atmosphere">Propagate through the atmosphere</h4>
<p>If checked, the guide star is propagated through the atmosphere using the model defined in the atmosphere block.</p>
<h4 id="sample-time">Sample Time</h4>
<p>The sampling time of the block outputs.</p>
<h2 id="sensor-tab">Sensor Tab</h2>
<h4 id="of-lenslet"># of lenslet</h4>
<p>The linear size of the lenslet array.</p>
<h4 id="lenslet-size">lenslet size</h4>
<p>The physical length of one lenslet project on M1 in meter.</p>
<h4 id="camera-resolution">camera resolution</h4>
<p>The detector resolution of the optical sensor in pixel.</p>
<h4 id="intensity-threshold">Intensity threshold</h4>
<p>The threshold on the lenslet integrated flux. Any lenslet, whose fraction of integrated intensity with respect to a fully illuminated lenslet is less than the threshold, is discarded.</p>
<h4 id="pixel-scale">Pixel scale</h4>
<p>The angular size of a pixel of the detector in arcsec. It is given by <span class="math inline">(<em>λ</em>/<em>d</em>)(<em>b</em>/<em>a</em>)</span> where both <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> are integers. <span class="math inline"><em>b</em></span> ia set by the adjusting the binning factor and <span class="math inline"><em>a</em></span> is set by adjusting the sampling factor.</p>
<h4 id="field-of-view">Field-of-view</h4>
<p>The field-of-view of the wavefront sensor in arcsec.</p>
<h4 id="exposure-time">Exposure time</h4>
<p>The detector exposure time. A value of -1 will set it to the same value that the exposure time.</p>
<h4 id="exposure-start">Exposure start</h4>
<p>Start of the exposure delay time.</p>
<h2 id="outputs-tab">Outputs Tab</h2>
<h3 id="star">Star</h3>
<p>Each output is derived on the telescope full pupil and/or on each segment.</p>
<h4 id="wavefront-error-rms">Wavefront error rms</h4>
<p>The RMS of the guide star wavefront in micron.</p>
<h4 id="piston">Piston</h4>
<p>The piston component of the guide star wavefront in micron.</p>
<h4 id="tip-tilt">Tip-tilt</h4>
<p>The tip-tilt component of the guide star wavefront in arcsec.</p>
<h3 id="sensor-1">Sensor</h3>
<h4 id="ee80">EE80</h4>
<p>The 80% encircled energy diameter in pixel.</p>
<h4 id="commands-load-calibration-from-file">Commands: Load calibration from file</h4>
<p>The name of the file where the calibration matrices are saved to. If the file already exists on the CEO server, the calibration matrices are loaded from this file.</p>
<h4 id="commands-calibration-inputs">Commands: Calibration inputs</h4>
<p>A ShackHartmann or GeometricShackHartmann sensor can return an estimate of the mirror commands based on its measuremnts. The mirror commands are given by the matrix multiplication of the inverse of the poke matrix and the sensor measurements. To generate the poke matrix, CEO needs to know which modes to calibrate from which mirror (<code>M1</code> or <code>M2</code>) and what stroke to apply to these modes.</p>
<p>The available mirror modes are:</p>
<ul>
<li><code>segment tip-tilt</code>: to calibrate the tip (Rx) and tilt (Ry) of each segment,</li>
<li><code>Txyz</code>: to calibrate the translation of each segment along its x, y and z axis,</li>
<li><code>Rxyz</code>: to calibrate the rotation of each segment along its x, y and z axis,</li>
<li><code>zernike</code>: to calibrate the Zernike modes of each segment,</li>
<li><code>bending modes</code>: to calibrate the bending modes of M1.</li>
</ul>
<p>For example:</p>
<ul>
<li><p>to calibrate M2 segment tip--tilt, the calibration inputs argument is</p>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">struct(<span class="st">&#39;M2_TT&#39;</span>,struct(<span class="st">&#39;mirror&#39;</span>,<span class="st">&#39;M2&#39;</span>,<span class="st">&#39;mode&#39;</span>,<span class="st">&#39;segment tip-tilt&#39;</span>,<span class="st">&#39;stroke&#39;</span>,<span class="fl">1e-6</span>)) </code></pre></div>
<p>where <code>M2_TT</code> is the name of the output port consisting of the 14 tip and tilts,</p></li>
<li><p>to calibrate all M1 modes and to concatenate all the modes into a single calibration matrix, the calibration inputs argument is</p>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">struct(<span class="st">&#39;M1_RTBM&#39;</span>,[struct(<span class="st">&#39;mirror&#39;</span>,<span class="st">&#39;M1&#39;</span>,<span class="st">&#39;mode&#39;</span>,<span class="st">&#39;Rxyz&#39;</span>,<span class="st">&#39;stroke&#39;</span>,<span class="fl">1e-6</span>),...
                  struct(<span class="st">&#39;mirror&#39;</span>,<span class="st">&#39;M1&#39;</span>,<span class="st">&#39;mode&#39;</span>,<span class="st">&#39;Txyz&#39;</span>,<span class="st">&#39;stroke&#39;</span>,<span class="fl">1e-6</span>),...
              struct(<span class="st">&#39;mirror&#39;</span>,<span class="st">&#39;M1&#39;</span>,<span class="st">&#39;mode&#39;</span>,<span class="st">&#39;bending modes&#39;</span>,<span class="st">&#39;stroke&#39;</span>,<span class="fl">1e-6</span>)])</code></pre></div></li>
</ul>
<h4 id="commands-command-vector-length">Commands: Command vector length</h4>
<p>The length of the different command vector defined with calibration inputs. For the examples in Calibration inputs, the length of the command vector are 14 for M2_TT and 20+20+7*n_mode for M1_RTBM. Modes Rz and Tz for segment #1 of M1 are un-observable by the WFS. Only mode Rz for segment #1 of M2 is un-observable by the WFS.</p>
<p>For M2_TT, the output vector has the following structure: <span class="math inline">[<em>R</em><sub><em>x</em><em>y</em></sub><sup>1</sup>, <em>R</em><sub><em>x</em><em>y</em></sub><sup>2</sup>, <em>R</em><sub><em>x</em><em>y</em></sub><sup>3</sup>, <em>R</em><sub><em>x</em><em>y</em></sub><sup>4</sup>, <em>R</em><sub><em>x</em><em>y</em></sub><sup>5</sup>, <em>R</em><sub><em>x</em><em>y</em></sub><sup>6</sup>, <em>R</em><sub><em>x</em><em>y</em></sub><sup>7</sup>]</span>. For M1_RTBM, the output vector is: <span class="math inline">[<em>R</em><sub><em>x</em><em>y</em><em>z</em></sub>, <em>T</em><sub><em>x</em><em>y</em><em>z</em></sub>, <em>B</em><em>M</em>]</span> with <span class="math inline">(<em>R</em><sub><em>x</em><em>y</em><em>z</em></sub> ≡ <em>X</em>, <em>T</em><sub><em>x</em><em>y</em><em>z</em></sub> ≡ <em>X</em>, <em>B</em><em>M</em> ≡ <em>X</em>)</span> and <span class="math inline"><em>X</em> = [<em>X</em><sup>1</sup>, <em>X</em><sup>2</sup>, <em>X</em><sup>3</sup>, <em>X</em><sup>4</sup>, <em>X</em><sup>5</sup>, <em>X</em><sup>6</sup>, <em>X</em><sup>7</sup>]</span>.</p>
<h4 id="commands-svd-truncation">Commands: SVD truncation</h4>
<p>The number of eigen values, from the singular value decomposition of the calibration matrix, that are discarded. If the calibration is loaded from a previously saved file, the threshold is re-applied and the pseudo-inverse is re-computed.</p>
<h4 id="commands-decoupling-segments">Commands: Decoupling segments</h4>
<p>If checked, eaach segment is controlled independently from the others, the lenslets that span across two segments are rejected and there are 7 command matrices i.e. as many as the number of segments per mirror. Otherwise M1 and M2 mirrors are controlled in the same way that non segmented mirrors.</p>
</body>
</html>
