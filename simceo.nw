
\section{Introduction}
\label{sec:introduction}

This documents describes SIMCEO, a interface between CEO and Simulink.
SIMCEO allows to seamlessly integrates CEO functionalities into a Simulink model.
A Simulink library, \emph{CEO}, provides a set of blocks that are used to instantiate CEO objects.
The blocks either send data to the CEO objects updating the state of these objects, or query data from the CEO objects.
The data received from the CEO objects is then forwarded to the other blocks of the Simulink model. 

\section{Installation}
\label{sec:installation}

This section describes the installation of the SIMCEO client i.e. the Matlab and Simulink part of SIMCEO.

To install SIMCEO on your computer, creates a directory \texttt{SIMCEO}, downloads the archive \texttt{simceo.zip} and extracts it in the \texttt{SIMCEO} directory.

In addition to Matlab and Simulink, the client relies of aws cli, ZeroMQ and UBJSON.

\subsection{AWS command line interface}
\label{sec:aws-cli}

The AWS command line interface (\texttt{aws cli}) allows to launch/terminate and to start/stop the AWS instances where the SIMCEO server resides.
To install it, follows the instructions at \\ \url{http://docs.aws.amazon.com/cli/latest/userguide/installing.html} \\
Once installed, open a terminal and at the shell prompt enter: \\\texttt{>> aws configure --profile gmto.control}\\ and answers the questions using the \texttt{gmto.control.credentials} file in the \texttt{etc/} directory.

\subsection{Matlab--ZMQ}
\label{sec:zeromq}

Matlab--ZMQ\footnote{\url{https://github.com/fagg/matlab-zmq}} is a Matlab wrapper for ZeroMQ.
ZeroMQ \footnote{\url{http://zeromq.org/}} is the messaging library used for the communications between SIMCEO client and server.
Both Matlab--ZMQ and ZeroMQ are shipped pre--compiled with SIMCEO. 
You need however to add, to the Matlab search path, the path to ZeroMQ.
To do so, move Matlab current folder to SIMCEO folder and at the Matlab prompt enter:
\\\texttt{>> addpath([pwd,'/matlab-zmq/your-os/lib/'])}\\\texttt{>> savepath}\\
where \texttt{your-os} is either \texttt{unix}, \texttt{mac} or \texttt{windows}.

\subsection{UBJSON}
\label{sec:ubjson}

Universal Binary JSON (UBJSON\footnote{\url{http://ubjson.org/}}) is the message format used to exchange data between SIMCEO client and server.
The Matlab UBJSON encoder and decoder is JSONLAB.
SIMCEO comes with its own version of JSONLAB that fixes a few bugs.
To add JSONLAB to the Matlab search path, move Matlab current folder to SIMCEO folder and at the Matlab prompt enter:
\\\texttt{>> addpath([pwd,'/jsonlab/'])}\\\texttt{>> savepath}\\

\section{Implementation}
\label{sec:implementation}

The interface between CEO and Simulink has two components a Matlab package \emph{ceo} on the user computer, the client, and a python module \emph{simulink} on a CEO AWS instance, the server.
A flowchart of SIMCEO is shown in Fig.~\ref{simceo-flowchart}.
The Matlab package is written with custom blocks using a \emph{Level--2 Matlab S--function}.
A \emph{Level--2 Matlab S--function} consists in a collection of functions that are called by the Simulink engine when a model is running.
Inside the \emph{Level--2 Matlab S--function}, the functions \emph{Start}, \emph{Terminate} and \emph{Outputs} are used to exchange information with CEO.
The Matlab class \emph{broker}  is responsible for starting the CEO server in the AWS cloud and for managing the communication with the server.

The requests from the client are managed by the \emph{broker} class of the \emph{simulink} python module on the server.
The \emph{simulink} module is providing three python classes to deal with Simulink requests: \emph{SGMT}, \emph{SAtmosphere} and \emph{SOpticalPath}.

The communication between the client and the server uses the Request/Reply messaging pattern of ZeroMQ.
The messages exchanged between the client and the server are formatted according to the UBJSON format.

\begin{figure}
  \label{simceo-flowchart}
  \centering
  \input{simceo.flowchart.tex}    
  \caption{SIMCEO flowchart.}
\end{figure}

\section{The simulink python module}
\label{sec:simul-pyth-module}


The python interface consists in the module \emph{simulink}:
<<simceo.py>>=
import threading
import time
import zmq
import ubjson
import ceo
import numpy as np
from collections import OrderedDict
import os
import shelve

SIMCEOPATH = os.path.abspath(os.path.dirname(__file__))

class Timer(object):
    def __init__(self, name=None):
        self.name = name

    def __enter__(self):
        self.tstart = time.time()

    def __exit__(self, type, value, traceback):
        if self.name:
            print '[%s]' % self.name,
        print 'Elapsed time: %s' % (time.time() - self.tstart)

<<CalibrationMatrix>>

<<S-function>>

<<SGMT>>
<<SAtmosphere>>
<<SOpticalPath>>

<<broker>>

if __name__ == "__main__":

    agent = broker()
    agent.start()
 
@

\subsection{The broker class}
\label{sec:broker-class}

% There are two broker classes, one written with python and acting as the CEO server, and the other is the Simulink client written with Matlab.

% \subsubsection{CEO server}
% \label{sec:ceo-server}

The broker class receives requests from the Simulink S--functions, processes the requests and sends a replies to the Simulink client.
%The broker class is the CEO server.
%It replies to requests received from the Simulink S--functions.
%It relies on ZeroMQ to send and receive messages to and from a Simulink model.
It inherits from the \emph{threading.Thread} class.
<<broker>>=
class broker(threading.Thread):

    def __init__(self):

        threading.Thread.__init__(self)
        
        self.context = zmq.Context()
        self.socket = self.context.socket(zmq.REP)
        self.address = "tcp://*:3650"
        self.socket.bind(self.address)
        
        self.sgmt = SGMT()
        self.satm = SAtmosphere()
        self.ops = []
        self.n_op = 0

    def __del__(self):

        self.release()

    def release(self):

        self.socket.close()
        self.context.term()

    <<broker get item>>

    <<broker run>>
@ 
The \emph{run} method 
<<broker run>>=
def run(self):
    
    while True:

        <<broker run details>>
@ 
waits for a request from a Simulink S--function:
<<broker run details>>=
msg = self.socket.recv()
jmsg = ubjson.loadb(msg)
#print jmsg
@
The message received from the S--function contains
\begin{itemize}
\item a class identifier, \emph{class\_id}: \textbf{GMT} for \emph{SGMT}, \textbf{ATM} for \emph{SAtmosphere} or \textbf{OP} for \emph{SOpticalPath},
\item a method identifier, \emph{method\_id}: \textbf{Start}, \textbf{Terminate}, \textbf{Update} or \textbf{Outputs},
\item a dictionnary of the arguments to the method,  \emph{args}.
\end{itemize}
The class method is invoked with:
<<broker run details>>=
class_id  = jmsg["class_id"]
method_id = jmsg["method_id"]
args_out = getattr( self[class_id], method_id )( **jmsg["args"] )
@ 
The dictionary--like call is implemented with 
<<broker get item>>=
def __getitem__(self,key):
    if key=="GMT":
        return self.sgmt
    elif key=="ATM":
        return self.satm
    elif key[:2]=="OP":
        if key[2:]:
            op_idx = int(key[2:]) - self.n_op + len(self.ops)
            return self.ops[op_idx]
        else:
            self.ops.append( SOpticalPath( len(self.ops) ,
                                           self.sgmt.gmt ,
                                           self.satm.atm ) )            
            self.n_op = len(self.ops)
            return self.ops[-1]
    else:
        raise KeyError("Available keys are: GMT, ATM or OP")
@ 
Each optical paths that is defined in the Simulink model is affected an unique ID tag made of the string \textbf{OP} followed by the index of the object in the optical path list \emph{ops}.
If the ID tag of the optical path is just \textbf{OP}, a new \emph{SOpticalPath} object is instanciated and appended to the list of optical path.

When the \emph{Terminate} method of an \emph{SOpticalPath} object is called, the object is removed from the optical path list \emph{ops}. 
<<broker run details>>=
if class_id[:2]=="OP" and method_id=="Terminate":
#    del(self.ops[int(class_id[2:])])
    self.ops.pop(0)
@
The value return by the method of the invoked object is sent back to the S--function:
<<broker run details>>=
self.socket.send(ubjson.dumpb(args_out))
@

\subsection{The S classes}
\label{sec:s-classes}

The S classes, \emph{SGMT}, \emph{SAtmosphere} and \emph{SOpticalPath}, are providing the interface with CEO classes. 
They mirror the \emph{Level--2 Matlab S--functions} by implementing the same method \emph{Start}, \emph{InitializeConditions}, \emph{Terminate}, \emph{Update} and \emph{Outputs}.
Each method is triggered by the corresponding function in the Matlab S--function with the exception of the \emph{Update} method that is triggered by the \emph{Outputs} function of the S--function.

An abstract class, \emph{Sfunction}, implements the four S--function method:
<<S-function>>=
from abc import ABCMeta, abstractmethod

class Sfunction:
    __metaclass__ = ABCMeta
    @abstractmethod
    def Start(self):
        pass
    @abstractmethod
    def Terminate(self):
        pass
    @abstractmethod
    def Update(self):
        pass
    @abstractmethod
    def Outputs(self):
        pass
    @abstractmethod
    def InitializeConditions(self):
        pass
@ 

\subsubsection{The SGMT class}
\label{sec:sgmt-class}

The \emph{SGMT} class is the interface class between a CEO \emph{GMT\_MX} object and a \emph{GMT Mirror}  Simulink block.
<<SGMT>>=
class SGMT(Sfunction):

    def __init__(self):
        self.gmt = ceo.GMT_MX()

    def Terminate(self, args=None):
        self.gmt = ceo.GMT_MX()
        return "GMT deleted!"
@

\paragraph{Start}

The message that triggers the call to the \emph{Start} method is
<<SGMT Start message>>=     
{
"class_id": "GMT",
"method_id": "Start",
"args": 
  {
    "mirror": "M1"|"M2",
    "mirror_args": 
      {
        "mirror_modes": u"bending modes"|u"zernike",
        "N_MODE": 162,
	"radial_order": ...
      }
  }
}
@
<<SGMT>>=
    def Start(self,mirror=None,mirror_args=None):
        #print mirror_args
        self.gmt[mirror] = getattr(ceo,"GMT_"+mirror)( **mirror_args )
        #print self.gmt[mirror].modes
        return "GMT"
@

\paragraph{Update}

The message that triggers the call to the \emph{Update} method is
<<SOpticalPath Update message>>=     
{
"class_id": "GMT",
"method_id": "Update",
"args": 
  {
    "mirror": "M1"|"M2",
    "inputs_args":
      {
        "TxyzRxyz": null,
        "mode_coefs": null
      }
  }
}
@
<<SGMT>>=
    def Update(self, mirror=None, inputs_args=None):
        #print "Updating GMT!"
        for key in inputs_args:
            data = np.array( inputs_args[key], order='C', dtype=np.float64 )
            data = np.transpose( np.reshape( data , (-1,7) ) )
            if key=="TxyzRxyz":
                #print np.array_str(data[:,:3], suppress_small=True)
                self.gmt[mirror].motion_CS.origin[:]       = data[:,:3]
                self.gmt[mirror].motion_CS.euler_angles[:] = data[:,3:]
                self.gmt[mirror].motion_CS.update()
            elif key=="mode_coefs":
                self.gmt[mirror].modes.a = np.copy( data, order='C')
                self.gmt[mirror].modes.update()
@
\paragraph{InitializeConditions}

<<SGMT>>=
    def InitializeConditions(self, args=None):
        pass
@
\paragraph{Outputs}

<<SGMT>>=
    def Outputs(self, args=None):
        pass
@ 

\subsubsection{The SAtmosphere class}
\label{sec:satmosphere-class}

The \emph{SAtmosphere} class is the interface class between a CEO \emph{GmtAtmosphere} object and a \emph{Atmosphere} Simulink block.
<<SAtmosphere>>=
class SAtmosphere(Sfunction):

    def __init__(self):
        self.atm = None

    def Start(self,atmosphere_args=None):
        self.atm = ceo.GmtAtmosphere( **atmosphere_args )
        return "ATM"

    def Terminate(self, args=None):
        self.atm = None
        return "Atmosphere deleted!"

    def InitializeConditions(self, args=None):
        pass

    def Outputs(self, args=None):
        pass

    def Update(self, args=None):
        pass
@ 

\subsubsection{The SOpticalPath class}
\label{sec:sopticalpath-class}

The \emph{SOpticalClass} gathers a source object \emph{src}, the GMT model object 
\emph{gmt}, an atmosphere object \emph{atm}, a sensor object \emph{sensor} and a calibration source \emph{calib\_src}.
<<SOpticalPath>>=
class SOpticalPath(Sfunction):

    def __init__(self, idx, gmt, atm):
        self.idx = idx
        self.gmt = gmt
        self.atm = atm
	self.sensor = None
        self.D = {}
@
\paragraph{Start}

The message that triggers the call to the \emph{Start} method is
<<SOpticalPath Start message>>=     
{
"class_id": "OP",
"method_id": "Start",
"args": 
  {
    "source_args": { ... } ,
    "sensor_class": null|"Imaging"|"ShackHartmann",
    "sensor_args": null|{ ... },
    "calibration_source": null|{ ... },...
    "miscellaneous_args": null|{...}
  }
}
@ 
<<SOpticalPath>>=
    def Start(self,source_args=None, sensor_class=None, sensor_args=None, 
              calibration_source_args=None, miscellaneous_args=None):
        print miscellaneous_args
        self.src = ceo.Source( **source_args )
        if sensor_class is not None:

            self.sensor = getattr(ceo,sensor_class)( **sensor_args )
            if calibration_source_args is None:
                self.calib_src = self.src
            else:
                self.calib_src = ceo.Source( **calibration_source_args )
	
	    self.src.reset()
	    self.gmt.reset()
            self.gmt.propagate(self.src)
	    self.sensor.calibrate(self.calib_src,miscellaneous_args['intensity_threshold'])
            if isinstance(self.sensor,(ceo.ShackHartmann,ceo.GeometricShackHartmann)):
                print "# of valid slopes: %d"%self.sensor.n_valid_slopes

            self.poke_matrix = {}
            self.comm_matrix = {}

        return "OP"+str(self.idx)
@
\paragraph{Terminate}

The message that triggers the call to the \emph{Terminate} method is
<<SOpticalPath Terminate message>>=     
{
"class_id": "OP",
"method_id": "Terminate",
"args": 
  {
    "args": null
  }
}
@ 
<<SOpticalPath>>=
    def Terminate(self, args=None):
        return "OpticalPath deleted!"
@
\paragraph{Update}

The message that triggers the call to the \emph{Update} method is
<<SOpticalPath Update message>>=     
{
"class_id": "OP",
"method_id": "Update",
"args": 
  {
    "inputs": null
  }
}
@ 
<<SOpticalPath>>=
    def Update(self, inputs=None):
        #print "Updating OP!"
        self.src.reset()
        self.gmt.propagate(self.src)
        #print "WFE RMS: %fnm"%self.src.wavefront.rms(-9)
	if self.sensor is not None:
	    self.sensor.reset()
            self.sensor.propagate(self.src)
            #self.sensor.readOut(T,0)
            self.sensor.process()
@
\paragraph{Outputs}

The message that triggers the call to the \emph{Outputs} method is
<<SOpticalPath Outputs message>>=     
{
"class_id": "OP",
"method_id": "Outputs",
"args": 
  {
      "outputs": ["wfe_rms"|"segment_wfe_rms"|"piston"|"segment_piston"|"ee80"]
  }
}
@ 
<<SOpticalPath>>=
    def Outputs(self, outputs=None):
        doutputs = OrderedDict()
        for element in outputs:
            #print self.src.wavefront.rms()
            doutputs[element] = self[element]
        return doutputs
@ 
and the dictionnary implementation is
<<SOpticalPath>>=
    def __getitem__(self,key):
        if key=="wfe_rms":
            return self.src.wavefront.rms().tolist()
        elif key=="segment_piston":
            return self.src.piston(where="segments").tolist()
        elif key=="ee80":
            return self.sensor.ee80()
        else:
            c = np.dot(self.comm_matrix[key],
                       self.sensor.valid_slopes.host(
                           shape=(self.sensor.n_valid_slopes,1) ) ).reshape(1,-1)
            c[c==0] = 1e-100
            return c.tolist()
@
\paragraph{InitializeConditions}

The message that triggers a call to the \emph{InitializeConditions} method is
<<SOpticalPath InitializeConditions message>>=     
{
"class_id": "OP",
"method_id": "InitializeConditions",
"args": 
  {
      "calibrations":
      {
          "M2_TT":
          {
            "mirror": "M2",
            "mode": "segment tip-tilt",
            "stroke": 1e-6
          }
          "M12_Rxyz": [
          {
            "mirror": "M1",
            "mode": "Rxyz",
            "stroke": 1e-6
          },
          {
            "mirror": "M2",
            "mode": "Rxyz",
            "stroke": 1e-6
          }]
      }
      "calibration_file": null,
      "SVD_truncation": 0
  }
}
@
<<SOpticalPath>>=
    def InitializeConditions(self, calibrations = None, 
                                   calibration_file = None,
                                   SVD_truncation = 0):
        print "@(SOpticalPath:InitializeConditions)>"
        if calibrations is not None:
            #import scipy.io.matlab as matlab
            #print kwargs
            k = 0
            if not isinstance(SVD_truncation,list):
                SVD_truncation = [SVD_truncation]
            if calibration_file is not None:
                filepath = os.path.join(SIMCEOPATH,"calibration_dbs",calibration_file)
                db = shelve.open(filepath)
                if os.path.isfile(filepath+".dir"):
                    print " . Loading command matrix from existing database %s!"%calibration_file
                    for key in db:
                        C = db[key]
                        C.nThreshold = SVD_truncation[k]
                        k+=1
                        self.comm_matrix[key] = C.M
                        db[key] = C
                    db.close()
                    return
                #db = shelve.open(SIMCEOPATH+"/calibration_dbs/"+calibration_file)
            with Timer():
                for key in calibrations: # Through calibrations
                    calibs = calibrations[key]
                    if not isinstance(calibs,list):
                        calibs = [calibs]
                    D = []
                    #print calibs
                    for c in calibs: # Through calib
                        #print c
                        D.append( self.gmt.calibrate(self.sensor,self.src,**c) )
                        self.gmt.reset()

                    Dc = np.concatenate( D, axis=1 )
                    C = CalibrationMatrix(Dc, SVD_truncation[k])
                    k+=1
                    self.poke_matrix[key] = C
                    #matlab.savemat('poke_matrix.mat',{'D':Dc})
                    self.comm_matrix[key] = self.poke_matrix[key].M

                    if calibration_file is not None:
                        print " . Saving command matrix to database %s!"%calibration_file
                        db[str(key)] = C

            if calibration_file is not None:
                db.close()
@ 

\subsection{The CalibrationMatrix class}
\label{sec:calibr-class}

The \emph{CalibrationMatrix} class is a container for several matrices:
\begin{itemize}
\item the poke matrix $D$,
\item the eigen modes $U,V$ and eigen values $S$ of the singular value decomposition of $D=USV^T$
\item the truncated inverse $M$ of $D$, $M=V\Lambda U^T$ where
  \begin{eqnarray}
    \label{eq:2}
      \Lambda_i &=& 1/S_i \forall i<n \nonumber\\
      \Lambda_i &=& 0 \forall i\geq n \nonumber    
  \end{eqnarray}
\end{itemize}

<<CalibrationMatrix>>=
class CalibrationMatrix(object):

    def __init__(self, D, n):
        print "@(CalibrationMatrix)> Computing the SVD and the pseudo-inverse..."
        self.D = D
        self._n = n
        with Timer():
            self.U,self.s,self.V = np.linalg.svd(D,full_matrices=False)
            self.V = self.V.T
            iS = 1./self.s
            if self._n>0:
                iS[-self._n:] = 0
            self.M = np.dot(self.V,np.dot(np.diag(iS),self.U.T))
            
    @property
    def nThreshold(self):
        "# of discarded eigen values"
        return self._n
    @nThreshold.setter
    def nThreshold(self, value):
        print "@(CalibrationMatrix)> Updating the pseudo-inverse..."
        self._n = value
        iS = 1./self.s
        if self._n>0:
            iS[-self._n:] = 0
        self.M = np.dot(self.V,np.dot(np.diag(iS),self.U.T))
@ 

\section{The ceo Matlab package}
\label{sec:ceo-matlab-package}


\subsection{The broker class}
\label{sec:matlab-broker-class}


<<broker.m>>=
classdef (Sealed=true) broker < handle
    % broker An interface to a CEO server
    %  The broker class launches an AWS instance and sets up the connection
    %  to the CEO server
    
    properties
        awspath % full path to the AWS CLI
        AMI_ID % The AWS AMI ID number
        instance_id % The AWS instance ID number
        public_ip % The AWS instance public IP
        zmqReset % ZMQ connection reset flag
    end
    
    properties (Access=private)
        instance_end_state
        ctx
        socket
    end
    
    methods

        <<broker client>>

        <<release ressources>>

        <<launch AWS AMI>>

        <<start AWS instance>>

        <<terminate AWS instance>>
    end
    
    methods(Static)

        <<instanciation and retrieval>>

        <<request and reply>>

        <<reset ZMQ socket>>
    end

end
@ 
The Matlab broker class starts an AWS machine and sets--up the ZeroMQ connection.
The 
<<broker client>>=
function self = broker(varargin)
    p = inputParser;
    addParameter(p,'awspath','')
    addParameter(p,'instance_id','')
    parse(p, varargin{:} )
    self.awspath     = p.Results.awspath;
    self.instance_id = p.Results.instance_id;
    <<broker client: AWS CLI path>>
    self.AMI_ID = 'ami-bc2b66dc';
    <<broker client: AWS instance launch>>
    self.ctx    = zmq.core.ctx_new();
    self.socket = zmq.core.socket(self.ctx, 'ZMQ_REQ');
    self.zmqReset = true;
end
@ 
If not argument is passed to the constructor, the routine selects the path to AWS CLI command \texttt{aws} based on the nature of the client OS.
<<broker client: AWS CLI path>>=
if isempty(self.awspath)
    if isunix
        [~,cmdout] = unix('which aws');
        if isempty(cmdout)
            if ismac
                self.awspath = '/usr/local/bin/aws';
            else
                % On Linux:
                self.awspath = '/home/rconan/anaconda2/bin/aws';
            end
        else
            self.awspath = cmdout;
        end
    elseif ispc
        % On Windows:
        self.awspath = 'aws.exe';
    else
        error('broker:osNotRecognize','Your machine is neither Unix nor Windows')
    end
end
[~,cmdout] = system(sprintf('%s --version',self.awspath));
disp(cmdout)
if isempty(strfind(cmdout,'aws-cli'))
    error('broker:awsNotFound',['Cannot find aws cli!\n',...
                        ' If aws cli is installed, find the path to ''aws''',...
                        ' and at Matlab prompt enter:\n',...
                        ' >> agent = ceo.broker.getBroker(''path_to_aws'')'])
end
@
If not instance ID is given, a new machine is launched based on the image corresponding to the set AWS AMI ID.
<<broker client: AWS instance launch>>=
if isempty(self.instance_id)
    run_instance(self)
    self.instance_end_state = 'terminate';
else
    start_instance(self)
    self.instance_end_state = 'stop';
end
@
\subsubsection{run\_instance}
\label{sec:run_instance}
 
<<launch AWS AMI>>=
function run_instance(self)
    cd('etc')
    [status,instance_json] = system(sprintf(['%s ec2 run-instances --image-id %s --count 1',...
                        ' --instance-type g2.2xlarge --key-name gmtocontrol.pem',...
                        ' --security-groups launch-wizard-2 --profile gmto.control'],...
                                       self.awspath, self.AMI_ID));
    if status~=0
        error('Launching AWS AMI %s failed!',self.AMI_ID')
    end
    cd('..')
    instance = loadjson(instance_json);
    self.instance_id = instance.Instances{1}(1).InstanceId;
    fprintf('>>>> WAITING FOR AWS INSTANCE %s TO START ... \n',self.instance_id)
    tic
    [status,~] = system(sprintf('%s ec2 wait instance-running --instance-ids %s --profile gmto.control',...
                                self.awspath,self.instance_id));
    toc
    if status~=0
        error('Starting AWS machine %s failed!',self.instance_id')
    end
    fprintf('>>>> WAITING FOR AWS INSTANCE %s TO INITIALIZE ... (This usually takes a few minutes!)\n',self.instance_id)
    tic
    [status,~] = system(sprintf('%s ec2 wait instance-status-ok --instance-ids %s --profile gmto.control',...
                                self.awspath,self.instance_id));
    toc
    if status~=0
        error('Starting AWS machine %s failed!',self.instance_id')
    end
    [status,~] = system(sprintf([...
        '%s cloudwatch put-metric-alarm --alarm-name CEO-SERVER-FAILSAFE',...
        ' --alarm-description "Terminate the instance when it is idle for 4 hours"',...
        ' --namespace "AWS/EC2" --dimensions Name=InstanceId,Value="%s"',...
        ' --statistic Average --metric-name CPUUtilization',...
        ' --comparison-operator LessThanThreshold --threshold 10 --period 3600',...
        ' --evaluation-periods 4 --alarm-actions arn:aws:automate:us-west-1:ec2:terminate --profile gmto.control'],...
                                         self.awspath,self.instance_id));
    if status~=0
        error('Setting alarm for AWS machine %s failed!',self.instance_id')
    end
    [status,public_ip_] = system(sprintf(['%s ec2 describe-instances --instance-ids %s',...
                        ' --output text',...
                        ' --query Reservations[*].Instances[*].PublicIpAddress --profile gmto.control'],...
                                    self.awspath, self.instance_id));    
    if status~=0
        error('Getting AWS machine public IP failed!')
    end
    self.public_ip = strtrim(public_ip_);
    fprintf('\n ==>> machine is up and running @%s\n',self.public_ip)
end
@ 
<<terminate AWS instance>>=
function terminate_instance(self)
    if strcmp(self.instance_end_state,'terminate')
        fprintf('@(broker)> Terminating instance %s!\n',self.instance_id)
        [status,~] = system(sprintf(['%s ec2 %s-instances',...
                            ' --instance-ids %s --profile gmto.control'],...
                                    self.awspath, self.instance_end_state, self.instance_id));
        if status~=0
            error('Terminating AWS instance %s failed!',self.instance_id')
        end
    end
end
@ 
The AWS command line interface must be installed and the instance ID must be provided: 
<<start AWS instance>>=
function start_instance(self)
% AWS machine instance ID:
% self.instance_id = 'i-063bf1d3bf97020e5';
    fprintf('@(broker)> Starting AWS machine %s...',self.instance_id)
    [status,~] = system(sprintf(['%s ec2 start-instances --instance-ids %s',...
                        ' --profile gmto.control'],...
                                self.awspath,self.instance_id));
    if status~=0
        error('Starting AWS machine %s failed!',self.instance_id')
    end
    [status,~] = system(sprintf(['%s ec2 wait instance-running --instance-ids %s',...
                        ' --profile gmto.control'],...
                                self.awspath,self.instance_id));
    if status~=0
        error('Starting AWS machine %s failed!',self.instance_id')
    end
    [status,public_ip_] = system(sprintf(['%s ec2 describe-instances --instance-ids %s',...
                        ' --output text',...
                        ' --query Reservations[*].Instances[*].PublicIpAddress',...
                        ' --profile gmto.control'],...
                                         self.awspath,self.instance_id));
    if status~=0
        error('Getting AWS machine public IP failed!')
    end
    self.public_ip = strtrim(public_ip_);
    fprintf('\n ==>> machine is up and running @%s\n',self.public_ip)
end
@
Once the instance is running, ZeroMQ connects the client to the server port of ZeroMQ on the AWS instance:
<<broker client: setup ZMQ connection>>=
self.socket = zmq.core.socket(self.ctx, 'ZMQ_REQ');
status = zmq.core.setsockopt(self.socket,'ZMQ_RCVTIMEO',60e3);
if status<0
    error('broker:zmqRcvTimeOut','Setting ZMQ_RCVTIMEO failed!')
end
status = zmq.core.setsockopt(self.socket,'ZMQ_SNDTIMEO',60e3);
if status<0
    error('broker:zmqSndTimeOut','Setting ZMQ_SNDTIMEO failed!')
end
address     = sprintf('tcp://%s:3650',self.public_ip);
zmq.core.connect(self.socket, address);
fprintf('@(broker)> %s connected at %s\n',class(self),address)
@
The allocated ZeroMQ ressources are released with:
<<release ressources>>=
function delete(self)
    fprintf('@(broker)> Deleting %s\n',class(self))
    terminate_instance(self)    
    zmq.core.close(self.socket);
    zmq.core.ctx_shutdown(self.ctx);
    zmq.core.ctx_term(self.ctx);
end
@
Two static methods are defined.
\emph{getBroker} instanciates and retrieves the broker object.
There can be only one broker object per Matlab session.
<<instanciation and retrieval>>=
function self = getBroker(varargin)
% getBroker Get a pointer to the broker object
%
% agent = ceo.broker.getBroker() % Launch an AWS instance and returns
% a pointer to the broker object
% agent = ceo.broker.getBroker('awspath','path_to_aws_cli') % Launch
% an AWS instance using the given AWS CLI path and returns a pointer to
% the broker object
% agent =
% ceo.broker.getBroker('instance_id','the_id_of_AWS_instance_to_start') 
% Launch the AWS instance 'instance_id' and returns a pointer to the broker object
    
    persistent this
    if isempty(this)
        fprintf('~~~~~~~~~~~~~~~~~~~')
        fprintf('\n SIMCEO CLIENT!\n')
        fprintf('~~~~~~~~~~~~~~~~~~~\n')
        this = ceo.broker(varargin{:});
    end
    self = this;
end
@
\emph{sendrecv} sends a request to the server and returns the server reply:
<<request and reply>>= 
function rcev_msg = sendrecv(send_msg)
    self = ceo.broker.getBroker();
    zmq.core.send( self.socket, uint8(send_msg) );
    rcev_msg = zmq.core.recv( self.socket , 2^24);
end
@ 
\emph{resetZMQ} resets the ZeroMQ socket
<<reset ZMQ socket>>=
function resetZMQ()
    self = ceo.broker.getBroker();
    if self.zmqReset
        [~,aws_instance_state] = system(...
            sprintf(['%s ec2 describe-instances --instance-ids %s',...
                     ' --output text',...
                     ' --query Reservations[*].Instances[*].State.Name --profile gmto.control'],...
            self.awspath, self.instance_id));
        if any(strcmp(strtrim(aws_instance_state),{'shutting-down','terminated'}))
            run_instance(self)
        end
        zmq.core.close(self.socket);
        <<broker client: setup ZMQ connection>>
    end
    self.zmqReset = false;
end
function setZmqResetFlag(val)
    self = ceo.broker.getBroker();
    self.zmqReset = val;
end
@ 

\subsection{The messages class}
\label{sec:the-messages-class}

The \emph{messages} class contains the messages that are sent by the different functions of the S--function.
Each CEO block instantiates a \emph{messages} class and tailors the messages in the initialization of the block mask.
It also holds the number of inputs and outputs of the block as well as the dimensions of the inputs and outputs.  
<<messages.m>>=
classdef messages < handle

    properties
        n_in
        dims_in
        n_out
        dims_out
        start
        update
        outputs
        terminate
        init
    end

    properties (Dependent)
       class_id
    end

    properties (Access=private)
        p_class_id
    end

    methods
        
        <<messages public methods>>
            
    end
    
    methods (Access=private)
        
        <<messages private methods>>

    end
 end
@  
There are five messages that corresponds to 4 four S--function routines:
<<messages public methods>>=
    function self = messages(class_id)

            self.p_class_id = class_id;
            proto_msg = struct('class_id',self.p_class_id,...
                               'method_id','',...
                               'tag','',...
                               'args',struct('args',[])); 
            % Start
            self.start     = proto_msg;
            self.start.method_id = 'Start';
            % InitializeConditions
            self.init      = proto_msg;
            self.init .method_id = 'InitializeConditions'; 
            % Outputs
            self.update    = proto_msg;
            self.update.method_id  = 'Update';
            self.outputs   = proto_msg;
            self.outputs.method_id = 'Outputs';
            % Terminate
            self.terminate = proto_msg;
            self.terminate.method_id = 'Terminate';
        end
@ 
The \emph{class\_id} property triggers an update of all the messages:         
<<messages public methods>>=
        function val = get.class_id(self)
            val = self.p_class_id;
        end
        function set.class_id(self,val)
            self.p_class_id = val;
            self.start.class_id     = val;
            self.init.class_id      = val;
            self.update.class_id    = val;
            self.outputs.class_id   = val;
            self.terminate.class_id = val;
        end
@
The properties of the blocks inputs and outputs are set with:
<<messages public methods>>=        
        function IO_setup(self,block)
            block.NumInputPorts  = self.n_in;
            for k_in=1:self.n_in
                block.InputPort(k_in).Dimensions  = self.dims_in{k_in};
                block.InputPort(k_in).DatatypeID  = 0;  % double
                block.InputPort(k_in).Complexity  = 'Real';
                block.InputPort(k_in).DirectFeedthrough = true;
            end
            block.NumOutputPorts = self.n_out;
            for k_out=1:self.n_out
                block.OutputPort(k_out).Dimensions   = self.dims_out{k_out};
                block.OutputPort(k_out).DatatypeID   = 0; % double
                block.OutputPort(k_out).Complexity   = 'Real';
                block.OutputPort(k_out).SamplingMode = 'sample';
            end
        end
@
The \emph{deal} method sends the message to the CEO server, waits for the server replies and process the reply.
<<messages public methods>>=        
        function deal(self,block,tag)
            switch tag
              case 'start'
                deal_start(self);
              case 'init'
                deal_init(self);
              case 'IO'
                deal_inputs(self, block);
                deal_outputs(self, block);
              case 'terminate'
                deal_terminate(self);
              otherwise
                fprintf(['@(messages)> deal: Unknown tag;',...
                         ' valid tags are: start, init, IO and terminate!'])
            end
        end
@ 
<<messages private methods>>=        
        function deal_start(self)
            ceo.broker.resetZMQ()
            jmsg = ceo.broker.sendrecv(saveubjson('',self.start));
            tag = char(loadubjson(char(jmsg)));
            self.class_id = tag;
            fprintf('@(%s)> Object created!\n',tag)
        end

        function deal_init(self)
            jmsg = ceo.broker.sendrecv(saveubjson('',self.init));
            fprintf('@(messages)> Object calibrated!\n')
        end
        
        function deal_terminate(self)
            jmsg = ceo.broker.sendrecv(saveubjson('',self.terminate));
            fprintf('@(%s)> %s\n',self.class_id,loadubjson(char(jmsg)))
            ceo.broker.setZmqResetFlag(true)
        end
@ 
\emph{deal\_inputs} reads the block inputs and affects the input data to the corresponding field in the update message:
<<messages private methods>>=                
        function deal_inputs(self, block)
            if self.n_in>0
                fields = fieldnames(self.update.args.inputs_args);
                for k_in=1:self.n_in
                    self.update.args.inputs_args.(fields{k_in}) = ...
                                          reshape(block.InputPort(k_in).Data,1,[]);
                end
            end
            ceo.broker.sendrecv(saveubjson('',self.update));
        end
@ 
\emph{deal\_outputs} affects the inputs from the CEO server to the corresponding data field of the block outputs:
<<messages private methods>>=                
        function deal_outputs(self, block)
            if self.n_out>0
                jmsg = ceo.broker.sendrecv(saveubjson('',self.outputs));
                outputs_msg = loadubjson(char(jmsg),'SimplifyCell',1);
                fields = fieldnames(outputs_msg);
                for k_out=1:self.n_out
                    data = outputs_msg.(fields{k_out});
                    if isempty(data)
                        data = NaN(size(block.OutputPort(k_out).Data));
                    end
                    block.OutputPort(k_out).Data = data;
                end
            end
        end
@ 

\subsection{The SCEO S--function}
\label{sec:sceo-s-function}

<<SCEO.m>>=
function SCEO(block)

setup(block);

<<SCEO setup>>

<<SCEO Start>>

<<SCEO Outputs>>

<<SCEO Terminate>>
@
\subsubsection{setup}
\label{sec:setup}

<<SCEO setup>>=
function setup(block)

msg_box   = get(gcbh,'UserData');
fprintf('__ %s: SETUP __\n',msg_box.class_id)
% Register number of ports
%block.NumInputPorts  = 0;

% Setup port properties to be inherited or dynamic
%block.SetPreCompInpPortInfoToDynamic;
%block.SetPreCompOutPortInfoToDynamic;

IO_setup(msg_box, block)

% Register sample times
%  [0 offset]            : Continuous sample time
%  [positive_num offset] : Discrete sample time
%
%  [-1, 0]               : Inherited sample time
%  [-2, 0]               : Variable sample time
block.SampleTimes = [1 0];

% Specify the block simStateCompliance. The allowed values are:
%    'UnknownSimState', < The default setting; warn and assume DefaultSimState
%    'DefaultSimState', < Same sim state as a built-in block
%    'HasNoSimState',   < No sim state
%    'CustomSimState',  < Has GetSimState and SetSimState methods
%    'DisallowSimState' < Error out when saving or restoring the model sim state
block.SimStateCompliance = 'DefaultSimState';

%% -----------------------------------------------------------------
%% The MATLAB S-function uses an internal registry for all
%% block methods. You should register all relevant methods
%% (optional and required) as illustrated below. You may choose
%% any suitable name for the methods and implement these methods
%% as local functions within the same file. See comments
%% provided for each function for more information.
%% -----------------------------------------------------------------

block.RegBlockMethod('Start', @Start);
block.RegBlockMethod('Outputs', @Outputs);     % Required
block.RegBlockMethod('Update', @Update);
block.RegBlockMethod('Terminate', @Terminate); % Required
block.RegBlockMethod('PostPropagationSetup', @PostPropagationSetup);
block.RegBlockMethod('InitializeConditions', @InitializeConditions);
%end setup

function PostPropagationSetup(block)
msg_box   = get(gcbh,'UserData');
fprintf('__ %s: PostPropagationSetup __\n',msg_box.class_id)

function InitializeConditions(block)
msg_box   = get(gcbh,'UserData');
fprintf('__ %s: InitializeConditions __\n',msg_box.class_id)
deal(msg_box,block,'init')
@
\subsubsection{Start}
\label{sec:start}

<<SCEO Start>>=
function Start(block)

msg_box   = get(gcbh,'UserData');
fprintf('__ %s: START  __\n',msg_box.class_id)
deal(msg_box,block,'start')
%set(gcbh,'UserData',msg_box)
tic
%end Start
@
\subsubsection{Outputs}
\label{sec:outputs}
 
<<SCEO Outputs>>=
function Outputs(block)

msg_box   = get(gcbh,'UserData');
%fprintf('__ %s: OUTPUTS __\n',msg_box.class_id)

deal(msg_box,block,'IO')

%end Outputs
@
\subsubsection{Terminate}
\label{sec:terminate}

<<SCEO Terminate>>=
function Update(block)

%end Update

function Terminate(block)

toc
msg_box = get(gcbh,'UserData');
deal(msg_box,block,'terminate')
set(gcbh,'UserData',[])
%end Terminate
@ 

\subsection{The block masks}
\label{sec:block-masks}

\subsubsection{Optical Path}
\label{sec:optical-path}

<<OpticalPath.md>>=
# Optical Path

## Guide Star Tab

#### Zenith angle

The guide star zenith angle, in arcsecond, given with respect to 
the telescope optical axis.

#### Azimuth angle

The guide star azimuth angle in degree.

#### Photometry

The guide star photometry to choose from.
This will set the wavelength, the spectral bandwidth and the magnitude zero
point.

The table below gives the values of those:

                             V       R       I       J       H       K       Ks 
--------------             -------- ------- ------- ------- ------- ------- -------
$\lambda$[$\mu$m]            0.550   0.640   0.790   1.215   1.654   2.179   2.157 
$\Delta\lambda$[$\mu$m]      0.090   0.150   0.150   0.260   0.290   0.410   0.320
Zero point[m$^{-2}.s^{-1}$]  8.97E9  10.87E9 7.34E9  5.16E9  2.99E9  1.90E9 1.49E9
--------------             -------- ------- ------- ------- ------- ------- -------- 

#### Magnitude

The guide star magnitude used to derive the number of photon taking
into account the guide star photometry.

#### \# of rays per lenslet

The \# of rays per lenslet corresponds to the number of rays used
for ray tracing through the telescope.
It has different meanings depending on the value of Sensor (See below).

### Sensor

The type of sensor:

* `None`: No sensor is used; 
the \# of rays per lenslet corresponds to the number of rays
across the telescope diameter, 
* `Imaging`: The sensor creates an image at the focal plane of the telescope; 
the \# of rays per lenslet corresponds to the number of rays
across the diameter of the imaging lens, 
* `ShackHartmann`: A shack-Hartmann model where the wavefront of the guide star is 
propagated from the telescope exit pupil to the focal plane of the lenslet array
using Fourier optics propagation; 
the \# of rays per lenslet corresponds to the number of rays across one lenslet,
* `GeometricShackHartmann`: A shack-Hartmann model where the centroids are derived 
from the finite difference of the wavefront averaged on the lenslets; 
the \# of rays per lenslet corresponds to the number of rays across one lenslet.

## Sensor Tab

#### \# of lenslet

The linear size of the lenslet array.

#### lenslet size

The physical length of one lenslet project on M1 in meter.

#### camera resolution

The detector resolution of the optical sensor in pixel.

#### Pixel scale

The angular size of a pixel of the detector in arcsec.
It is given by 
$(\lambda/d)(b/a)$
where both $a$ and $b$
are integers

## Outputs Tab

### Star

#### Wavefront error rms

The RMS, over the telescope pupil, of the guide star wavefront in meter.

#### Piston

The piston component of the guide star wavefront in meter.

#### Segment Piston

The piston component of the guide star wavefront, per segment, in meter.
 
### Sensor

#### EE80

The 80% encircled energy diameter in pixel. 

#### Commands: Load calibration from file

The name of the file where the calibration matrices are saved to.
If the file already exists on the CEO server, the calibration matrices are loaded from this file.

#### Commands: Calibration inputs

A ShackHartmann or GeometricShackHartmann sensor can return an estimate of
the mirror commands based on its measuremnts.
The mirror commands are given by the matrix multiplication of
the inverse of the poke matrix and the sensor measurements.
To generate the poke matrix, CEO needs to know which modes to calibrate
from which mirror (`M1` or `M2`) and what stroke to apply to these modes.

The available mirror modes are: 

* `segment tip-tilt`: to calibrate the tip (Rx) and tilt (Ry) of each segment,
* `Txyz`: to calibrate the translation of each segment along its x, y and z axis,
* `Rxyz`: to calibrate the rotation of each segment along its x, y and z axis,
* `zernike`: to calibrate the Zernike modes of each segment,
* `bending modes`: to calibrate the bending modes of M1.

For example:

* to calibrate M2 segment tip--tilt, the calibration inputs argument is 
```matlab
struct('M2_TT',struct('mirror','M2','mode','segment tip-tilt','stroke',1e-6)) 
```
where `M2_TT` is the name of the output port consisting of the 14 tip and tilts,

* to calibrate all M1 modes and to concatenate all the modes into a single calibration matrix, the calibration inputs argument is 
```matlab
struct('M1_RTBM',[struct('mirror','M1','mode','Rxyz','stroke',1e-6),...
	              struct('mirror','M1','mode','Txyz','stroke',1e-6),...
                  struct('mirror','M1','mode','bending modes','stroke',1e-6)])
```

#### Commands: Command vector length

The length of the different command vector defined with calibration inputs.
For the examples in Calibration inputs, the length of the command vector are 14 for M2_TT and 20+20+7*n_mode for M1_RTBM.
Modes Rz and Tz for segment #1 of M1 are un-observable by the WFS.
Only mode Rz for segment #1 of M2 is un-observable by the WFS.

For M2_TT, the output vector has the following structure: $[R_{xy}^1,R_{xy}^2,R_{xy}^3,R_{xy}^4,R_{xy}^5,R_{xy}^6,R_{xy}^7]$.
For M1_RTBM, the output vector is: $[R_{xyz},T_{xyz},BM]$ with $(R_{xyz} \equiv X,T_{xyz} \equiv X,BM \equiv X)$ and $X=[X^1,X^2,X^3,X^4,X^5,X^6,X^7]$.

#### Commands: SVD truncation

The number of eigen values, from the singular value decomposition of the calibration matrix, that are discarded.
If the calibration is loaded from a previously saved file, the threshold is re-applied and the pseudo-inverse is re-computed.

@ 
\subsubsection{GMT Mirror}
\label{sec:gmt-mirror}

<<GMTMirror.md>>=
# GMT Mirror

#### Mirror

Either the primary M1 or the secondary M2 mirror.

### Mirror commands

The mirrors accept two types of intputs:

#### Txyz and Rxyz rigid body

A $7\times6$ matrix concatenating row wise the vectors `[Tx,Ty,Tz,Rx,Ry,Rz]` of segments 1 to 7.

#### Mirror mode coefficients

The coefficients of the segments modal basis that is used to shape the segments.
It is a $7\times$`n_mode` matrix of either bending mode for M1 or Zernike coefficients for M2.
@ 
\section{The CEO server}
\label{sec:ceo-server-1}

The CEO daemon is start at boot time with the \emph{CEO.sh} shell script.
It must be placed in the \texttt{/etc/init.d} directory.
<<CEO.sh>>=
#!/bin/sh -e

DAEMON="/home/ubuntu/Dropbox/SIMCEO/etc/ceo_server" 
daemon_OPT=""  
DAEMONUSER="root" 
daemon_NAME="ceo_server" 
PIDFILE=/var/run/$daemon_NAME.pid

PATH="/sbin:/bin:/usr/sbin:/usr/bin" #Ne pas toucher

test -x $DAEMON || exit 0

. /lib/lsb/init-functions

d_start () {
        log_daemon_msg "Starting system $daemon_NAME Daemon"
        start-stop-daemon --background --name $daemon_NAME --start --quiet --make-pidfile --pidfile "$PIDFILE" --chuid $DAEMONUSER --exec $DAEMON -- $daemon_OPT
        log_end_msg $?
}

d_stop () {
        log_daemon_msg "Stopping system $daemon_NAME Daemon"
        start-stop-daemon --name $daemon_NAME --stop --retry 5 --quiet --pidfile "$PIDFILE" --name $daemon_NAME
        log_end_msg $?
}

case "$1" in

        start|stop)
                d_${1}
                ;;

        restart|reload|force-reload)
                        d_stop
                        d_start
                ;;

        force-stop)
               d_stop
                killall -q $daemon_NAME || true
                sleep 2
                killall -q -9 $daemon_NAME || true
                ;;

        status)
                status_of_proc "$daemon_NAME" "$DAEMON" "system-wide $daemon_NAME" && exit 0 || exit $?
                ;;
        *)
                echo "Usage: /etc/init.d/$daemon_NAME {start|stop|force-stop|restart|reload|force-reload|status}"
                exit 1
                ;;
esac
exit 0
@ 
The CEO server is started from the CEO daemon with the \emph{ceo\_server} bash script:
<<ceo\_server>>=
#!/bin/bash
echo $(date)" Starting Script" > /tmp/ceo_server.log  
env LD_LIBRARY_PATH=/usr/local/cuda/lib64 PYTHONPATH=/home/ubuntu/CEO/python /home/ubuntu/anaconda/bin/python /home/ubuntu/Dropbox/SIMCEO/simceo.py >> /tmp/ceo_server.log
